/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://github.com/motdotla/dotenv?sponsor=1",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs = require("fs");
    var path2 = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path2.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path2.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      let dotenvPath = path2.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options) {
        if (options.path != null) {
          let envPath = options.path;
          if (Array.isArray(envPath)) {
            for (const filepath of options.path) {
              if (fs.existsSync(filepath)) {
                envPath = filepath;
                break;
              }
            }
          }
          dotenvPath = _resolveHome(envPath);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        } else {
          if (debug) {
            _debug("No encoding is specified. UTF-8 is used by default");
          }
        }
      }
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
        return { parsed };
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${dotenvPath} ${e.message}`);
        }
        return { error: e };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QuickPluginSwitcher
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/main_modal.ts
var import_obsidian8 = require("obsidian");

// src/utils.ts
function isEnabled(modal, id) {
  return modal.app.plugins.enabledPlugins.has(id);
}
function removeItem(arr, value) {
  const index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
  }
  return arr;
}
function formatNumber(num, precision = 2) {
  const map = [
    { suffix: "T", threshold: 1e12 },
    { suffix: "B", threshold: 1e9 },
    { suffix: "M", threshold: 1e6 },
    { suffix: "K", threshold: 1e3 },
    { suffix: "", threshold: 1 }
  ];
  const found = map.find((x) => Math.abs(num) >= x.threshold);
  if (found) {
    const formatted = (num / found.threshold).toFixed(precision) + found.suffix;
    return formatted;
  }
  return num;
}
function calculateTimeElapsed(datePasted) {
  const delta = Math.abs(new Date().getTime() - datePasted.getTime()) / 1e3;
  const years = Math.floor(delta / (86400 * 365));
  if (years >= 2) {
    return `${years} years ago`;
  } else if (years === 1) {
    return "1 year ago";
  }
  const months = Math.floor(delta / (86400 * 30));
  if (months >= 2) {
    return `${months} months ago`;
  } else if (months === 1) {
    return "1 month ago";
  }
  const days = Math.floor(delta / 86400);
  if (days >= 2) {
    return `${days} days ago`;
  } else if (days === 1) {
    return "1 day ago";
  }
  const hours = Math.floor(delta / 3600) % 24;
  if (hours >= 2) {
    return `${hours} hours ago`;
  } else if (hours === 1) {
    return "1 hour ago";
  }
  const minutes = Math.floor(delta / 60) % 60;
  if (minutes >= 2) {
    return `${minutes} minutes ago`;
  } else if (minutes === 1) {
    return "1 minute ago";
  }
  return "seconds ago";
}
function hasKeyStartingWith(obj, prefix) {
  for (const key in obj) {
    if (key.startsWith(prefix)) {
      return true;
    }
  }
  return false;
}
function getSelectedContent() {
  const selection = window.getSelection();
  return selection == null ? void 0 : selection.toString();
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const length = binaryString.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

// src/secondary_modals.ts
var import_obsidian6 = require("obsidian");

// src/community-plugins_modal.ts
var import_fs = require("fs");
var import_obsidian4 = require("obsidian");

// src/modal_utils.ts
var import_obsidian2 = require("obsidian");

// src/types/variables.ts
var COMMPLUGINS = "https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-plugins.json";
var COMMPLUGINSTATS = "https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-plugin-stats.json";
var Filters = {
  All: "all",
  Enabled: "enabled",
  Disabled: "disabled",
  EnabledFirst: "enabledFirst",
  MostSwitched: "mostSwitched",
  ByGroup: "byGroup",
  Hidden: "hidden"
};
var CommFilters = {
  All: "all",
  NotInstalled: "not installed",
  Installed: "installed",
  ByGroup: "byGroup",
  Hidden: "hidden"
};
var SortBy = {
  Downloads: "by downloads",
  Alpha: "by alphanum",
  Updated: "by (recent) update",
  Released: "by (recent) release"
};
var Groups = {
  SelectGroup: "All"
};
var GroupsComm = {
  SelectGroup: "All"
};
var DEFAULT_SETTINGS = {
  lastFetchExe: 0,
  savedVersion: "0.0.0",
  installed: {},
  wasEnabled: [],
  sortBy: "Downloads",
  filters: "All",
  selectedGroup: "SelectGroup",
  search: "",
  numberOfGroups: 4,
  groups: {},
  showHotKeys: true,
  // commnunity plugins
  pluginStats: {},
  plugins: [],
  commPlugins: {},
  filtersComm: "All",
  selectedGroupComm: "SelectGroup",
  numberOfGroupsComm: 4,
  groupsComm: {},
  byAuthor: false,
  invertFiltersComm: false
};

// src/groups.ts
var import_obsidian = require("obsidian");
var getFilters = (modal, contentEl) => {
  const { plugin } = modal;
  const { settings } = plugin;
  if (settings.filtersComm === CommFilters.ByGroup)
    return;
  new import_obsidian.ButtonComponent(contentEl).setIcon("arrow-up-narrow-wide").setClass("comm-button").setTooltip(
    "change type of sorting"
  ).buttonEl.addEventListener("click", async (evt) => {
    const menu = new import_obsidian.Menu();
    for (const key in SortBy) {
      menu.addItem(
        (item) => item.setTitle(SortBy[key]).onClick(async () => {
          settings.sortBy = key;
          await reOpenModal(modal);
        }).setChecked(key === settings.sortBy)
      );
    }
    menu.showAtMouseEvent(evt);
  });
};
var byGroupDropdowns = (modal, contentEl) => {
  const { plugin } = modal;
  const { settings } = plugin;
  if (modal instanceof QPSModal && settings.filters === Filters.ByGroup) {
    getDropdownOptions(Groups, plugin.lengthAll);
  } else if (modal instanceof CPModal && settings.filtersComm === CommFilters.ByGroup) {
    getDropdownOptions(GroupsComm, Object.keys(settings.commPlugins).length);
  }
  function getDropdownOptions(groups, length) {
    const dropdownOptions = {};
    for (const groupKey in groups) {
      const groupIndex = getIndexFromSelectedGroup(groupKey);
      if (groupKey === "SelectGroup") {
        dropdownOptions[groupKey] = groups[groupKey] + `(${length})`;
      } else if (!groupIsEmpty(groupIndex, modal)) {
        dropdownOptions[groupKey] = getEmojiForGroup(groupIndex).emoji + groups[groupKey];
      }
    }
    new import_obsidian.DropdownComponent(contentEl).addOptions(dropdownOptions).setValue(settings.selectedGroup).onChange(async (value) => {
      settings.selectedGroup = value;
      await reOpenModal(modal);
    });
  }
};
var addDelayToGroup = (modal, groupNumber, span, inGroup) => {
  var _a;
  const { plugin } = modal;
  const { settings } = plugin;
  const currentValue = (((_a = settings.groups[groupNumber]) == null ? void 0 : _a.time) || 0).toString();
  const input = createInput(span, currentValue);
  if (!input)
    return;
  input.onblur = async () => {
    await setDelay(input, settings, groupNumber, span, modal);
  };
  input.onkeydown = async (event) => {
    if (event.key === "Enter") {
      await setDelay(input, settings, groupNumber, span, modal);
    }
  };
  const setDelay = async (input2, settings2, groupNumber2, span2, modal2) => {
    const value = parseInt(input2.value) || 0;
    settings2.groups[groupNumber2].time = value;
    span2.textContent = `${value}`;
    if (inGroup.length) {
      await applyGroupDelay(inGroup, groupNumber2, modal2);
    }
    await reOpenModal(modal2);
  };
};
var applyGroupDelay = async (inGroup, groupNumber, modal) => {
  var _a;
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed } = settings;
  for (const id of inGroup) {
    installed[id].time = (_a = settings.groups[groupNumber]) == null ? void 0 : _a.time;
    const condition = !!installed[id].time;
    installed[id].delayed = condition;
    settings.groups[groupNumber].applied = condition;
    if (installed[id].enabled) {
      await modal.app.plugins.disablePluginAndSave(id);
      condition ? await modal.app.plugins.enablePlugin(id) : await modal.app.plugins.enablePluginAndSave(id);
      installed[id].enabled = true;
    }
  }
};
var groupMenuQPS = (evt, modal, groupNumber, span) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed } = settings;
  const inGroup = getPluginsInGroup(modal, groupNumber);
  const menu = new import_obsidian.Menu();
  menu.addItem(
    (item) => item.setTitle("Delay group (or dblclick icon)").onClick(() => {
      addDelayToGroup(modal, groupNumber, span, inGroup);
    })
  );
  menu.addSeparator();
  menu.addItem(
    (item) => item.setTitle("Show/hide group content").onClick(async () => {
      await hideOnCLick(modal, groupNumber, inGroup);
    })
  );
  menu.addSeparator();
  const toEnable = inGroup.filter((id) => installed[id].enabled === false);
  menu.addItem(
    (item) => item.setTitle("Enable all plugins in group").setDisabled(!inGroup.length || !toEnable.length).onClick(async () => {
      if (toEnable) {
        await Promise.all(
          toEnable.map(async (id) => {
            conditionalEnable(modal, id);
            installed[id].enabled = true;
            modal.plugin.saveSettings();
          })
        );
        plugin.getLength();
        new import_obsidian.Notice("All plugins enabled.", 2500);
        await reOpenModal(modal);
      }
    })
  );
  const toDisable = inGroup.filter((id) => installed[id].enabled === true);
  menu.addItem(
    (item) => item.setTitle("Disable all plugins in group").setDisabled(!inGroup.length || !toDisable.length).onClick(async () => {
      if (toDisable) {
        await Promise.all(
          toDisable.map(async (id) => {
            modal.app.plugins.disablePluginAndSave(
              id
            );
            installed[id].enabled = false;
          })
        );
        plugin.getLength();
        new import_obsidian.Notice("All plugins disabled.", 2500);
        await reOpenModal(modal);
      }
    })
  );
  menu.addSeparator();
  createClearGroupsMenuItem(modal, menu, groupNumber);
  menu.showAtMouseEvent(evt);
};
var groupMenuCPM = async (evt, modal, groupNumber) => {
  const menu = new import_obsidian.Menu();
  menu.addItem((item) => {
    item.setTitle("Install & enable in group");
    item.onClick(async () => {
      const inGroup = getPluginsInGroup(
        modal,
        groupNumber
      );
      if (!inGroup.length)
        return;
      await installAllPluginsInGroup(modal, inGroup, true);
    });
  });
  menu.addItem((item) => {
    item.setTitle("Install plugins in group");
    item.onClick(async () => {
      const inGroup = getPluginsInGroup(
        modal,
        groupNumber
      );
      if (!inGroup.length)
        return;
      await installAllPluginsInGroup(modal, inGroup);
    });
  });
  menu.addItem((item) => {
    item.setTitle("Uninstall plugins in group");
    item.onClick(async () => {
      await uninstallAllPluginsInGroup(modal, groupNumber);
    });
  });
  if (modal.app.isMobile) {
    menu.addSeparator();
    const inGroup = getPluginsInGroup(
      modal,
      groupNumber
    );
    menu.addItem(
      (item) => item.setTitle("Show/hide group content").onClick(async () => {
        await hideOnCLick(modal, groupNumber, inGroup);
      })
    );
  }
  menu.addSeparator();
  createClearGroupsMenuItem(modal, menu, groupNumber);
  menu.showAtMouseEvent(evt);
};
var groupMenu = async (evt, modal, groupNumber, span) => {
  if (modal instanceof QPSModal && span) {
    groupMenuQPS(evt, modal, groupNumber, span);
  } else {
    await groupMenuCPM(evt, modal, groupNumber);
  }
};
async function uninstallAllPluginsInGroup(modal, groupNumber) {
  const inGroup = getPluginsInGroup(modal, groupNumber);
  if (!inGroup.length)
    return;
  const { plugin } = modal;
  const { settings } = plugin;
  const { commPlugins } = settings;
  for (const id of inGroup) {
    if (!isInstalled(id))
      continue;
    await this.app.plugins.uninstallPlugin(id);
    new import_obsidian.Notice(`${commPlugins[id].name} uninstalled`, 2500);
  }
  await reOpenModal(modal);
}
async function installAllPluginsInGroup(modal, inGroup, enable = false) {
  const { plugin } = modal;
  const { settings } = plugin;
  const { commPlugins } = settings;
  for (const id of inGroup) {
    if (isInstalled(id)) {
      new import_obsidian.Notice(`${commPlugins[id].name} already installed`, 2500);
      continue;
    }
    const manifest = await getManifest(modal, id);
    if (!manifest)
      continue;
    const lastVersion = manifest.version;
    await this.app.plugins.installPlugin(commPlugins[id].repo, lastVersion, manifest);
    if (enable) {
      await modal.app.plugins.enablePluginAndSave(id);
      new import_obsidian.Notice(`${commPlugins[id].name} enabled`, 2500);
    }
  }
  await reOpenModal(modal);
}
var getPluginsInGroup = (modal, groupNumber) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed, commPlugins } = settings;
  if (modal instanceof QPSModal)
    return Object.keys(installed).filter(
      (id) => installed[id].groupInfo.groupIndices.indexOf(groupNumber) !== -1
    );
  else {
    return Object.keys(commPlugins).filter(
      (id) => commPlugins[id].groupCommInfo.groupIndices.indexOf(groupNumber) !== -1
    );
  }
};
var setGroupTitle = (modal, Groups2, numberOfGroups) => {
  var _a, _b, _c, _d;
  const { plugin } = modal;
  const { settings } = plugin;
  const currentGroupKeys = Object.keys(Groups2);
  for (let i = 1; i < currentGroupKeys.length; i++) {
    const key = currentGroupKeys[i];
    delete Groups2[key];
  }
  for (let i = 1; i <= numberOfGroups; i++) {
    if (modal instanceof CPModal) {
      if (!settings.groupsComm[i]) {
        settings.groupsComm[i] = {
          name: "",
          hidden: false
        };
      }
      const groupKey = ((_a = settings.groupsComm[i]) == null ? void 0 : _a.name) ? (_b = settings.groupsComm[i]) == null ? void 0 : _b.name : `Group${i}`;
      Groups2[`Group${i}`] = `${groupKey}`;
    } else {
      if (!settings.groups[i]) {
        settings.groups[i] = {
          name: "",
          delayed: false,
          time: 0,
          applied: false,
          hidden: false
        };
      }
      const groupKey = ((_c = settings.groups[i]) == null ? void 0 : _c.name) ? (_d = settings.groups[i]) == null ? void 0 : _d.name : `Group${i}`;
      Groups2[`Group${i}`] = `${groupKey}`;
    }
  }
};
function addRemoveItemGroupMenuItems(modal, submenu, pluginItem, alt) {
  const { plugin } = modal;
  const { settings } = plugin;
  Object.keys(Groups).forEach((groupKey) => {
    var _a, _b;
    const { lengthGroup, groupIndex, groupValue } = getGroupIndexLength(
      modal,
      groupKey
    );
    const getGroup = pluginItem instanceof QPSModal ? ((_a = pluginItem.groupInfo) == null ? void 0 : _a.groupIndices.indexOf(groupIndex)) !== -1 : ((_b = pluginItem.groupCommInfo) == null ? void 0 : _b.groupIndices.indexOf(groupIndex)) !== -1;
    if (groupKey !== "SelectGroup" && lengthGroup && getGroup) {
      let value = alt ? `remove ${groupValue}` : `${groupValue}`;
      submenu.addItem((subitem) => {
        subitem.setTitle(value).onClick(async () => {
          var _a2, _b2;
          const plugins = pluginItem instanceof QPSModal ? (_a2 = pluginItem.groupInfo) == null ? void 0 : _a2.groupIndices : (_b2 = pluginItem.groupCommInfo) == null ? void 0 : _b2.groupIndices;
          for (const index of plugins) {
            if (index === groupIndex) {
              removeItem(
                plugins,
                index
              );
              if (groupIsEmpty(groupIndex, modal)) {
                settings.selectedGroup = "SelectGroup";
              }
              break;
            }
          }
          await reOpenModal(modal);
        });
      });
    }
  });
}
var getGroupIndexLength = (modal, groupKey) => {
  const groupIndex = getIndexFromSelectedGroup(groupKey);
  const { settings } = modal.plugin;
  const { installed, commPlugins } = settings;
  let lengthGroup, groupValue;
  if (modal instanceof QPSModal) {
    lengthGroup = Object.keys(installed).filter(
      (id) => installed[id].groupInfo.groupIndices.indexOf(groupIndex) !== -1
    ).length;
    groupValue = Groups[groupKey];
  } else {
    lengthGroup = Object.keys(commPlugins).filter(
      (id) => commPlugins[id].groupCommInfo.groupIndices.indexOf(groupIndex) !== -1
    ).length;
    groupValue = GroupsComm[groupKey];
  }
  return { groupIndex, lengthGroup, groupValue };
};
function addRemoveGroupMenuItems(modal, submenu, groupNumber) {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed, commPlugins, groups, groupsComm } = settings;
  let groupName;
  if (modal instanceof QPSModal) {
    groupName = groupNameFromIndex(Groups, groupNumber);
  } else {
    groupName = groupNameFromIndex(GroupsComm, groupNumber);
  }
  const { lengthGroup, groupValue } = getGroupIndexLength(modal, groupName);
  if (groupName !== "SelectGroup" && lengthGroup) {
    submenu.addItem((subitem) => {
      subitem.setTitle(`${groupValue}`).onClick(async () => {
        let pluginsRemoved = false;
        if (modal instanceof QPSModal) {
          for (const id in installed) {
            const index = installed[id].groupInfo.groupIndices.indexOf(groupNumber);
            if (index !== -1) {
              if (groups[groupNumber].hidden) {
                groups[groupNumber].hidden = false;
                installed[id].groupInfo.hidden = false;
              }
              installed[id].groupInfo.groupIndices.splice(index, 1);
              pluginsRemoved = true;
            }
          }
        } else {
          for (const id in commPlugins) {
            const index = commPlugins[id].groupCommInfo.groupIndices.indexOf(groupNumber);
            if (index !== -1) {
              if (groupsComm[groupNumber].hidden) {
                groupsComm[groupNumber].hidden = false;
                commPlugins[id].groupCommInfo.hidden = false;
              }
              commPlugins[id].groupCommInfo.groupIndices.splice(index, 1);
              pluginsRemoved = true;
            }
          }
        }
        await reOpenModal(modal);
        if (pluginsRemoved) {
          new import_obsidian.Notice(`All plugins removed from ${groupValue}`, 2500);
        } else {
          new import_obsidian.Notice(`No plugins found in ${groupValue} group`, 2500);
        }
      });
    });
  }
}
var addToGroupSubMenu = (submenu, pluginItem, modal, alt) => {
  Object.entries(Groups).forEach(([key, value]) => {
    const groupIndices = modal instanceof QPSModal ? pluginItem.groupInfo.groupIndices : pluginItem.groupCommInfo.groupIndices;
    const groupIndex = getIndexFromSelectedGroup(key);
    if (key !== "SelectGroup") {
      if (alt) {
        value = `add to ${value}`;
      }
      const { groups, installed } = modal.plugin.settings;
      submenu.addItem(
        (item) => item.setTitle(value).setDisabled(groupIndices.indexOf(groupIndex) !== -1).onClick(async () => {
          if (groupIndices.length === 6)
            return;
          groupIndices == null ? void 0 : groupIndices.push(groupIndex);
          if (groups[groupIndex].hidden)
            installed[pluginItem.id].groupInfo.hidden = true;
          await reOpenModal(modal);
        })
      );
    }
  });
};
var editGroupName = (modal, span, groupNumber) => {
  var _a, _b;
  const { plugin } = modal;
  const { settings } = plugin;
  const currentValue = (modal instanceof CPModal ? ((_a = settings.groupsComm[groupNumber]) == null ? void 0 : _a.name) || "" : (_b = settings.groups[groupNumber]) == null ? void 0 : _b.name) || "";
  const updateGroupName = (value) => {
    var _a2;
    if (modal instanceof CPModal) {
      settings.groupsComm[groupNumber].name = value || GroupsComm[groupNumber];
      span.textContent = settings.groupsComm[groupNumber].name;
    } else {
      settings.groups[groupNumber].name = value || Groups[groupNumber];
      span.textContent = (_a2 = settings.groups[groupNumber]) == null ? void 0 : _a2.name;
    }
  };
  const handleBlurOrEnter = () => {
    setTimeout(async () => {
      if (!modal.isDblClick && input) {
        updateGroupName(input.value);
        await reOpenModal(modal);
      }
    }, 100);
  };
  const input = createInput(span, currentValue);
  if (input) {
    input.onblur = handleBlurOrEnter;
    input.onkeydown = (event) => {
      if (event.key === "Enter") {
        handleBlurOrEnter();
      }
    };
  }
};
var getEmojiForGroup = (groupNumber) => {
  const emojis = ["\u{1F7E1}", "\u{1F535}", "\u{1F534}", "\u26AA\uFE0F", "\u{1F7E3}", "\u{1F7E2}"];
  const colors = [
    "#FFD700",
    "#0000FF",
    "#FF0000",
    "#FFFFFF",
    "#800080",
    "#00FF00"
  ];
  return { emoji: emojis[groupNumber - 1], color: colors[groupNumber - 1] };
};
var getCirclesItem = (indices) => {
  const len = indices.length;
  let background = "";
  if (len === 1) {
    const { color } = getEmojiForGroup(indices[len - 1]);
    background = `background: ${color};`;
  } else if (len === 2) {
    const { color: color1 } = getEmojiForGroup(indices[len - 2]);
    const { color: color2 } = getEmojiForGroup(indices[len - 1]);
    background = `background: linear-gradient(90deg, ${color1} 50%, ${color2} 50%);`;
  }
  const content = `<div
            style="${background}"
            class="qps-item-line-group"
            >
            &nbsp;
            </div>
            `;
  return content;
};
function groupIsEmpty(groupIndex, modal) {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed, commPlugins } = settings;
  if (modal instanceof QPSModal) {
    return !Object.keys(installed).some(
      (id) => installed[id].groupInfo.groupIndices.indexOf(groupIndex) !== -1
    );
  } else {
    return !Object.keys(commPlugins).some(
      (id) => commPlugins[id].groupCommInfo.groupIndices.indexOf(groupIndex) !== -1
    );
  }
}
function groupNameFromIndex(groups, index) {
  for (let key in groups) {
    if (key.endsWith(index.toString())) {
      return key;
    }
  }
  return null;
}
function getIndexFromSelectedGroup(str) {
  if (str === "SelectGroup")
    return 0;
  else
    return parseInt(str.slice(-1));
}
async function rmvAllGroupsFromPlugin(modal, pluginItem) {
  const { plugin } = modal;
  if ("repo" in pluginItem) {
    pluginItem.groupCommInfo.groupIndices = [];
    plugin.settings.selectedGroupComm = "SelectGroup";
  } else {
    pluginItem.groupInfo.groupIndices = [];
    plugin.settings.selectedGroup = "SelectGroup";
  }
  await reOpenModal(modal);
}
function groupNbFromEmoticon(el) {
  var _a, _b;
  const groupNameEl = el.nextElementSibling;
  return parseInt((_b = (_a = groupNameEl == null ? void 0 : groupNameEl.querySelector("span")) == null ? void 0 : _a.textContent) != null ? _b : "");
}
function groupNbFromGrpName(groupName) {
  var _a;
  return parseInt((_a = groupName == null ? void 0 : groupName.match(/\((\d+)\)$/)) == null ? void 0 : _a[1]);
}

// src/modal_utils.ts
var reset = async (modal) => {
  const { plugin } = modal;
  const confirmed = await confirm("Reset most switched values?", 250);
  if (confirmed) {
    plugin.reset = true;
    plugin.getLength();
    await reOpenModal(modal);
    new import_obsidian2.Notice("Done", 2500);
  } else {
    new import_obsidian2.Notice("Operation cancelled", 2500);
  }
};
var sortByName = (plugin, listItems) => {
  const { settings } = plugin;
  const { installed } = settings;
  listItems.sort((a, b) => installed[a].name.localeCompare(installed[b].name));
};
var sortSwitched = (plugin, listItems) => {
  const { settings } = plugin;
  const { installed } = settings;
  listItems.sort((a, b) => installed[b].switched - installed[a].switched);
};
var togglePlugin = async (modal, pluginItem) => {
  const { plugin } = modal;
  pluginItem.enabled = !pluginItem.enabled;
  pluginItem.enabled ? await conditionalEnable(modal, pluginItem.id) : await modal.app.plugins.disablePluginAndSave(pluginItem.id);
  plugin.getLength();
  await reOpenModal(modal);
};
async function openDirectoryInFileManager(modal, pluginItem) {
  let shell = window.electron.remote.shell;
  const filePath = modal.app.vault.adapter.getFullPath(
    pluginItem.dir
  );
  try {
    await shell.openPath(filePath);
  } catch (err) {
    const plugins = modal.app.vault.adapter.getFullPath(
      ".obsidian/plugins"
    );
    await shell.openPath(plugins);
  }
}
var delayedReEnable = async (modal, id) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed } = settings;
  await modal.app.plugins.disablePluginAndSave(id);
  await modal.app.plugins.enablePlugin(id);
  installed[id].enabled = true;
};
var conditionalEnable = async (modal, id) => {
  const { installed } = modal.plugin.settings;
  if (installed[id].delayed && installed[id].time > 0) {
    await modal.app.plugins.enablePlugin(id);
    await modal.plugin.saveSettings();
  } else {
    installed[id].switched++;
    await modal.app.plugins.enablePluginAndSave(id);
  }
};
var selectValue = (input) => {
  input == null ? void 0 : input.setSelectionRange(0, input == null ? void 0 : input.value.length);
};
var modeSort = (modal, plugin, listItems) => {
  const { settings } = plugin;
  const { installed, filters } = settings;
  if (plugin.reset) {
    listItems.forEach((id) => {
      installed[id].switched = 0;
    });
    plugin.reset = false;
  }
  if (filters === Filters.EnabledFirst) {
    const enabledItems = listItems.filter((id) => installed[id].enabled);
    const disabledItems = listItems.filter((id) => !installed[id].enabled);
    sortByName(plugin, enabledItems);
    sortByName(plugin, disabledItems);
    listItems = [...enabledItems, ...disabledItems];
  } else if (filters === Filters.ByGroup) {
    const groupIndex = getIndexFromSelectedGroup(
      settings.selectedGroup
    );
    if (groupIndex !== 0) {
      const groupedItems = listItems.filter((i) => {
        return installed[i].groupInfo.groupIndices.indexOf(groupIndex) !== -1;
      });
      listItems = groupedItems;
      sortByName(plugin, listItems);
    } else {
      sortByName(plugin, listItems);
    }
  } else if (filters === Filters.MostSwitched) {
    sortByName(plugin, listItems);
    sortSwitched(plugin, listItems);
  } else if (filters === Filters.Hidden) {
    return getHidden(modal);
  } else {
    sortByName(plugin, listItems);
  }
  return listItems;
};
function createInput(el, currentValue) {
  if (el) {
    const input = document.createElement("input");
    input.type = "text";
    input.value = currentValue;
    el.replaceWith(input);
    input.focus();
    selectValue(input);
    return input;
  } else {
    return void 0;
  }
}
var pressDelay = (modal) => {
  modal.pressed = true;
  setTimeout(() => {
    modal.pressed = false;
  }, 1);
};
function getInstalled() {
  return Object.keys(this.app.plugins.manifests);
}
function getHidden(modal) {
  const { settings } = modal.plugin;
  const { installed, commPlugins } = settings;
  if (modal instanceof QPSModal) {
    return Object.keys(installed).filter((item) => installed[item].groupInfo.hidden);
  } else {
    return Object.keys(commPlugins).filter((item) => commPlugins[item].groupCommInfo.hidden);
  }
}
function isInstalled(id) {
  return getInstalled().includes(id);
}
async function reOpenModal(modal, searchInit = false) {
  await modal.plugin.saveSettings();
  modal.searchInit = searchInit;
  await modal.onOpen();
}
async function openPluginSettings(modal, pluginItem) {
  var _a;
  const enabled = (_a = modal.plugin.settings.installed[pluginItem.id]) == null ? void 0 : _a.enabled;
  if (!enabled) {
    new import_obsidian2.Notice("Plugin disabled, no Settings to show", 3500);
    return;
  }
  const pluginSettings = modal.app.setting.openTabById(
    pluginItem.id
  );
  if (!pluginSettings) {
    new import_obsidian2.Notice("No Settings on this plugin", 2500);
    return;
  }
  await modal.app.setting.open();
  await (pluginSettings == null ? void 0 : pluginSettings.display());
}
var showHotkeysFor = async function(modal, pluginItem) {
  const enabled = modal instanceof CPModal ? modal.plugin.settings.installed[pluginItem.id].enabled : pluginItem.enabled;
  if (!enabled) {
    new import_obsidian2.Notice("Plugin disabled, no HotKeys to show", 3500);
    return;
  }
  const condition = await getHkeyCondition(modal, pluginItem);
  if (!condition) {
    new import_obsidian2.Notice("No HotKeys on this plugin", 2500);
    return;
  }
  await this.app.setting.open();
  await this.app.setting.openTabById("hotkeys");
  const tab = await this.app.setting.activeTab;
  tab.searchComponent.inputEl.value = pluginItem.name + ":";
  tab.updateHotkeyVisibility();
  tab.searchComponent.inputEl.blur();
};
function modifyGitHubLinks(content, pluginItem) {
  const regex = /!\[([^\]]*)\]\(([^)]*)\)/g;
  return content.replace(/\/blob\//g, "/raw/").replace(regex, (match, alt, url) => {
    if (!url.startsWith("http")) {
      if (url.startsWith(".")) {
        url = `https://github.com/${pluginItem.repo}/raw/HEAD${url.substr(1)}`;
      } else {
        url = `https://github.com/${pluginItem.repo}/raw/HEAD/${url}`;
      }
    }
    return `![${alt}](${url})`;
  });
}
function getElementFromMousePosition(modal) {
  if (modal.mousePosition) {
    const elementFromPoint = document.elementFromPoint(
      modal.mousePosition.x,
      modal.mousePosition.y
    );
    return elementFromPoint;
  }
  return null;
}

// src/community-plugins_modal.ts
var path = __toESM(require("path"));

// src/Console.ts
var import_obsidian3 = require("obsidian");
var DEBUG = "false";
if (import_obsidian3.Platform.isDesktopApp) {
  require_main().config();
  DEBUG = "false";
}
var Console = {
  debug: (...args) => {
    if (DEBUG.trim().toLowerCase() === "true") {
      console.debug(...args);
    }
  },
  log: (...args) => {
    if (DEBUG.trim().toLowerCase() === "true") {
      console.log(...args);
    }
  }
};

// src/community-plugins_modal.ts
var CPModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.searchTyping = true;
    this.isDblClick = false;
    this.pressed = false;
    this.searchInit = true;
    this.getMousePosition = (event) => {
      this.mousePosition = { x: event.clientX, y: event.clientY };
    };
    this.getHandleKeyDown = async (event) => {
      await handleKeyDown(event, this);
    };
    this.getHandleContextMenu = async (evt) => {
      if (this.isDblClick)
        return;
      await handleContextMenu(evt, this);
    };
    this.getHandleDblClick = (evt) => {
      if (this.isDblClick)
        return;
      handleDblClick(evt, this);
    };
    this.getHandleClick = (evt) => {
      handleClick(evt, this);
    };
    this.addHeader = (contentEl) => {
      const { plugin } = this;
      const { settings } = plugin;
      new import_obsidian4.DropdownComponent(contentEl).addOptions({
        all: `All(${Object.keys(settings.commPlugins).length})`,
        installed: `Installed(${getInstalled().length})`,
        notInstalled: import_obsidian4.Platform.isMobile ? "Not Installed" : `Not Installed(${Object.keys(settings.commPlugins).length - getInstalled().length})`,
        byGroup: `By Group`,
        hidden: `Hidden(${getHidden(this).length})`
      }).setValue(settings.filtersComm).onChange(async (value) => {
        settings.filtersComm = value;
        await plugin.saveSettings();
        await reOpenModal(this);
      });
      getFilters(this, contentEl);
      byGroupDropdowns(this, contentEl);
      checkbox(this, contentEl, "Inv");
    };
    this.plugin = plugin;
  }
  // Add H to hide groups on handlekeydown
  removeListeners() {
    this.modalEl.removeEventListener("mousemove", this.getMousePosition);
    document.removeEventListener("keydown", this.getHandleKeyDown);
    this.modalEl.removeEventListener("contextmenu", this.getHandleContextMenu);
    this.modalEl.removeEventListener("dblclick", this.getHandleDblClick);
    if (this.app.isMobile) {
      this.modalEl.removeEventListener("click", this.getHandleClick);
    }
  }
  container() {
    const { contentEl } = this;
    this.modalEl.addClass("community-plugins-modal");
    this.header = contentEl.createEl("div", {
      cls: "qps-community-header"
    });
    this.search = contentEl.createEl("div", {
      cls: "qps-community-search"
    });
    this.groups = contentEl.createEl("div", {
      cls: ["qps-community-groups", "qps-comm-group"]
    });
    this.hotkeysDesc = contentEl.createEl("p", { cls: "qps-hk-desc" });
    this.items = contentEl.createEl("div", { cls: "qps-community-items" });
    this.modalEl.addEventListener("mousemove", this.getMousePosition);
    document.addEventListener("keydown", this.getHandleKeyDown);
    this.modalEl.addEventListener("contextmenu", this.getHandleContextMenu);
    this.modalEl.addEventListener("dblclick", this.getHandleDblClick);
    if (this.app.isMobile) {
      this.modalEl.addEventListener("click", this.getHandleClick);
    }
  }
  async onOpen() {
    this.removeListeners();
    const { plugin, contentEl } = this;
    const { settings } = plugin;
    if (this.searchInit)
      settings.search = "";
    this.searchInit = true;
    contentEl.empty();
    this.container();
    setGroupTitle(this, GroupsComm, settings.numberOfGroupsComm);
    this.addHeader(this.header);
    await addSearch(this, this.search, "Search community plugins");
    if (import_obsidian4.Platform.isDesktopApp) {
      searchCommDivButton(this, this.search);
    }
    this.addGroups(this, this.groups);
    if (settings.showHotKeys && !this.app.isMobile)
      this.setHotKeysdesc();
    await this.addItems(settings.search);
  }
  addGroups(modal, contentEl) {
    const groups = Object.values(GroupsComm);
    for (let i = 1; i < groups.length; i++) {
      const groupKey = groups[i];
      contentEl.createEl(
        "span",
        {
          cls: "qps-group-span-container"
        },
        (cont) => {
          const preSpan = cont.createEl(
            "span",
            {
              cls: "qps-circle-title-group"
            },
            (el) => {
              circleCSSModif(this, el, i);
            }
          );
          const span = cont.createEl("span", {
            cls: "qps-groups-name",
            text: `${groupKey}`
          }, (el) => {
            var _a;
            const { plugin } = modal;
            const { settings } = plugin;
            const hidden = (_a = settings.groupsComm[i]) == null ? void 0 : _a.hidden;
            if (hidden) {
              el.style.textDecoration = "line-through";
            } else {
              el.style.textDecoration = "none";
            }
          });
          const groupNumberText = `(<span class="shortcut-number">${i}</span>)`;
          span.insertAdjacentHTML("beforeend", groupNumberText);
        }
      );
    }
    if (!this.app.isMobile) {
      contentEl.createSpan({
        text: `> (h)\u{1F441}\uFE0F (\u{1F5B1}\uFE0Fx2)name`
      });
    } else {
      contentEl.createSpan({
        text: `(\u{1F5B1}\uFE0Fx2)name,icon:delay (\u{1F5B1}\uFE0F...)context-menu`
      });
    }
  }
  setHotKeysdesc() {
    const numberOfGroups = this.plugin.settings.numberOfGroupsComm;
    this.hotkeysDesc.createSpan(
      {
        text: `(1-${numberOfGroups})\u2795 (0)\u274C `
      },
      (el) => {
        el.createSpan({ text: "(g)" }, (el2) => {
          let gitHubIcon = el2.createSpan({ cls: "git-hub-icon" });
          (0, import_obsidian4.setIcon)(gitHubIcon, "github");
        });
        el.createSpan({
          text: ` (\u{1F5B1}\uFE0Fx2/ctrl)Readme`
        });
      }
    );
  }
  async addItems(value) {
    const { plugin } = this;
    const { settings } = plugin;
    const { commPlugins, pluginStats } = settings;
    let listItems = doSearchCPM(value, commPlugins);
    listItems = cpmModeSort(this, listItems);
    sortItemsBy.bind(this)(this, listItems);
    await this.drawItemsAsync.bind(this)(listItems, pluginStats, value);
  }
  hightLightSpan(value, text) {
    if (value.trim() === "") {
      return text;
    } else {
      const regex = new RegExp(`(${value})`, "gi");
      return text.replace(regex, `<span class="highlighted">$&</span>`);
    }
  }
  async drawItemsAsync(listItems, pluginStats, value) {
    const batchSize = 50;
    let index = 0;
    const { plugin } = this;
    const { settings } = plugin;
    const { commPlugins, filtersComm } = settings;
    while (index < listItems.length) {
      const batch = listItems.slice(index, index + batchSize);
      const promises = batch.map(async (item) => {
        var _a, _b;
        if (item.hasOwnProperty("hidden") && item.hidden) {
          commPlugins[item].groupCommInfo.hidden = true;
        }
        if (item.hasOwnProperty("hidden")) {
          delete item.hidden;
        }
        if (((_a = commPlugins[item].groupCommInfo) == null ? void 0 : _a.hidden) && !commPlugins[item].groupCommInfo.groupIndices.length) {
          commPlugins[item].groupCommInfo.hidden = false;
        }
        if (filtersComm !== CommFilters.ByGroup) {
          if (((_b = commPlugins[item].groupCommInfo) == null ? void 0 : _b.hidden) && filtersComm !== CommFilters.Hidden) {
            return;
          }
        }
        const itemContainer = this.items.createEl("div", { cls: "qps-comm-block" });
        if (this.app.isMobile) {
          const div = itemContainer.createEl(
            "div",
            {
              cls: "button-container"
            },
            (el) => {
              vertDotsButton(el);
            }
          );
        }
        const name = this.hightLightSpan(value, commPlugins[item].name);
        const author = `by ${this.hightLightSpan(value, commPlugins[item].author)}`;
        const desc = this.hightLightSpan(value, commPlugins[item].description);
        itemContainer.createDiv(
          { cls: "qps-community-item-name" },
          (el) => {
            el.innerHTML = name;
            if (isInstalled(item)) {
              el.createSpan({ cls: "installed-span", text: "installed" });
            }
            if (isEnabled(this, item)) {
              const span = el.createSpan({ cls: "enabled-span" });
              (0, import_obsidian4.setIcon)(span, "power");
            }
          }
        );
        itemContainer.createDiv({ cls: "qps-community-item-author" });
        const pluginInfo = pluginStats[item];
        if (pluginInfo) {
          itemContainer.createDiv(
            { cls: "qps-community-item-downloads" },
            (el) => {
              el.innerHTML = author;
              el.createSpan({ cls: "downloads-span" }, (el2) => {
                const preSpan = el2.createSpan();
                const span = el2.createSpan({
                  text: formatNumber(pluginInfo.downloads, 1).toString(),
                  cls: "downloads-text-span"
                });
                addGroupCircles(this, span, item);
                (0, import_obsidian4.setIcon)(preSpan, "download-cloud");
              });
            }
          );
          const lastUpdated = new Date(pluginInfo.updated);
          const timeSinceUpdate = calculateTimeElapsed(lastUpdated);
          itemContainer.createDiv({
            cls: "qps-community-item-updated",
            text: `Updated ${timeSinceUpdate}`
          });
        }
        itemContainer.createDiv({ cls: "qps-community-item-desc" }, (el) => {
          el.innerHTML = desc;
        });
        return itemContainer;
      });
      await Promise.all(promises);
      index += batchSize;
    }
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.removeListeners();
    await this.plugin.installedUpdate();
    new QPSModal(this.app, this.plugin).open();
  }
};
async function fetchData(url) {
  try {
    const response = await (0, import_obsidian4.requestUrl)(url);
    const data = await response.json;
    if (data)
      return data;
  } catch (error) {
    return null;
  }
}
async function getReadMe(item) {
  const repo = item.repo;
  const readmeFormats = ["README.md", "README.org"];
  for (const format of readmeFormats) {
    const repoURL = `https://api.github.com/repos/${repo}/contents/${format}`;
    try {
      const response = await (0, import_obsidian4.requestUrl)(repoURL);
      if (response.status === 200) {
        return await response.json;
      }
      if (format === "README.md") {
        break;
      }
    } catch (error) {
      console.warn(`Error fetching ${format}`);
    }
  }
  return null;
}
async function getManifest(modal, id) {
  var _a;
  const { commPlugins } = modal.plugin.settings;
  const repo = (_a = commPlugins[id]) == null ? void 0 : _a.repo;
  const repoURL = `https://raw.githubusercontent.com/${repo}/HEAD/manifest.json`;
  try {
    const response = await (0, import_obsidian4.requestUrl)(repoURL);
    return await response.json;
  } catch (error) {
    Console.log("id, commPlugins[id]", id, commPlugins[id]);
    console.warn("Error fetching manifest");
  }
  return null;
}
async function getReleaseVersion(modal, id, manifest) {
  const { commPlugins } = modal.plugin.settings;
  const repo = commPlugins[id].repo;
  const releaseUrl = `https://github.com/${repo}/releases/tag/${manifest.version}`;
  try {
    const response = await (0, import_obsidian4.requestUrl)(releaseUrl);
    if (response)
      return true;
    return false;
  } catch (e) {
    return false;
  }
}
function sortItemsBy(modal, listItems) {
  const { settings } = modal.plugin;
  const { commPlugins } = settings;
  if (settings.sortBy === "Downloads") {
    listItems.sort((a, b) => {
      return settings.invertFiltersComm ? commPlugins[a].downloads - commPlugins[b].downloads : commPlugins[b].downloads - commPlugins[a].downloads;
    });
  } else if (settings.sortBy === "Updated") {
    listItems.sort((a, b) => {
      return settings.invertFiltersComm ? commPlugins[a].updated - commPlugins[b].updated : commPlugins[b].updated - commPlugins[a].updated;
    });
  } else if (settings.sortBy === "Alpha") {
    listItems.sort((a, b) => {
      return settings.invertFiltersComm ? commPlugins[b].name.localeCompare(commPlugins[a].name) : commPlugins[a].name.localeCompare(commPlugins[b].name);
    });
  } else if (settings.sortBy === "Released") {
    listItems.sort((a, b) => {
      const indexA = settings.plugins.findIndex((id) => id === commPlugins[a].id);
      const indexB = settings.plugins.findIndex((id) => id === commPlugins[b].id);
      return settings.invertFiltersComm ? indexA - indexB : indexB - indexA;
    });
  }
}
function cpmModeSort(modal, listItems) {
  const { settings } = modal.plugin;
  const { filtersComm, commPlugins } = settings;
  if (filtersComm === CommFilters.Installed) {
    const installedPlugins = getInstalled();
    return listItems.filter((item) => installedPlugins.includes(item));
  } else if (filtersComm === CommFilters.NotInstalled) {
    const installedPlugins = getInstalled();
    return listItems.filter((item) => !installedPlugins.includes(item));
  } else if (filtersComm === CommFilters.ByGroup) {
    const groupIndex = getIndexFromSelectedGroup(
      settings.selectedGroup
    );
    if (groupIndex !== 0) {
      const groupedItems = listItems.filter((i) => {
        var _a;
        return ((_a = commPlugins[i].groupCommInfo) == null ? void 0 : _a.groupIndices.indexOf(groupIndex)) !== -1;
      });
      return groupedItems;
    } else
      return listItems;
  } else if (filtersComm === CommFilters.Hidden) {
    return getHidden(modal);
  } else {
    return listItems;
  }
}
var handleKeyDown = async (event, modal) => {
  const elementFromPoint = getElementFromMousePosition(modal);
  const targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-comm-block"
  );
  const targetGroupIcon = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-circle-title-group"
  );
  const targetGroup = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-groups-name"
  );
  if (targetBlock) {
    modal.searchTyping = false;
    const matchingItem = findMatchingItem(modal, targetBlock);
    if (matchingItem) {
      await handleHotkeysCPM(
        modal,
        event,
        matchingItem
      );
    }
  } else if ((targetGroupIcon || targetGroup) && event.key === "h") {
    modal.searchTyping = false;
    await toggleVisibility(modal, targetGroupIcon, targetGroup);
  } else {
    modal.searchTyping = true;
  }
};
var handleHotkeysCPM = async (modal, evt, pluginItem) => {
  if (modal.pressed) {
    return;
  }
  pressDelay(modal);
  const { plugin } = modal;
  const { settings } = plugin;
  const { groupsComm, commPlugins } = settings;
  const numberOfGroups = settings.numberOfGroupsComm;
  const KeyToSettingsMap = {
    g: async () => await openGitHubRepo(modal, pluginItem)
  };
  const keyPressed = evt.key;
  let groupIndices = pluginItem.groupCommInfo.groupIndices;
  const key = parseInt(keyPressed);
  if (key > 0 && key <= numberOfGroups) {
    if (groupIndices.length === 6)
      return;
    const index = groupIndices.indexOf(key);
    if (index === -1) {
      groupIndices.push(key);
      if (groupsComm[key].hidden)
        commPlugins[pluginItem.id].groupCommInfo.hidden = true;
      await reOpenModal(modal);
    }
  } else if (keyPressed in KeyToSettingsMap) {
    KeyToSettingsMap[keyPressed]();
  } else if (evt.metaKey || evt.ctrlKey) {
    new ReadMeModal(plugin.app, modal, pluginItem).open();
  } else if (keyPressed === "Delete" || keyPressed === "Backspace" || keyPressed === "0") {
    if (groupIndices.length === 1) {
      pluginItem.groupCommInfo.groupIndices = [];
      await plugin.saveSettings();
      await reOpenModal(modal);
    } else if (groupIndices.length > 1) {
      const menu = new import_obsidian4.Menu();
      menu.addItem(
        (item) => item.setTitle("Remove item group(s)").setDisabled(true).setDisabled(true)
      );
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle("All").onClick(async () => {
          await rmvAllGroupsFromPlugin(modal, pluginItem);
        })
      );
      for (const groupIndex of groupIndices) {
        const { emoji } = getEmojiForGroup(groupIndex);
        menu.addItem(
          (item) => item.setTitle(`${emoji} group ${groupIndex}`).onClick(async () => {
            groupIndices = removeItem(
              groupIndices,
              groupIndex
            );
            await plugin.saveSettings();
            await reOpenModal(modal);
          })
        );
      }
      menu.showAtPosition(modal.mousePosition);
    }
  }
};
var addGroupCircles = (modal, el, item) => {
  const { settings } = modal.plugin;
  const { commPlugins } = settings;
  const indices = commPlugins[item].groupCommInfo.groupIndices;
  if (indices.length) {
    if (indices.length < 3) {
      const content = getCirclesItem(indices);
      el.insertAdjacentHTML("afterend", content);
    }
    if (indices.length >= 3 && indices.length < 5) {
      const [valeur0, valeur1, ...part2] = indices;
      const part1 = [valeur0, valeur1];
      const content1 = getCirclesItem(part1);
      el.insertAdjacentHTML("afterend", content1);
      const content2 = getCirclesItem(part2);
      el.insertAdjacentHTML("afterend", content2);
    } else if (indices.length >= 5) {
      const [valeur0, valeur1, valeur2, valeur3, ...part3] = indices;
      const part1 = [valeur0, valeur1];
      const part2 = [valeur2, valeur3];
      const content1 = getCirclesItem(part1);
      el.insertAdjacentHTML("afterend", content1);
      const content2 = getCirclesItem(part2);
      el.insertAdjacentHTML("afterend", content2);
      const content3 = getCirclesItem(part3);
      el.insertAdjacentHTML("afterend", content3);
    }
  }
};
async function installFromList(modal, enable = false) {
  let properties = ["openFile"];
  let filePaths = window.electron.remote.dialog.showOpenDialogSync({
    title: "Pick json list file of plugins to install",
    properties,
    filters: ["JsonList", "json"]
  });
  if (filePaths && filePaths.length) {
    const contenu = (0, import_fs.readFileSync)(filePaths[0], "utf-8");
    try {
      const pluginList = JSON.parse(contenu);
      if (Array.isArray(pluginList)) {
        const plugins = Object.keys(modal.plugin.settings.commPlugins).filter(
          (id) => {
            return pluginList.includes(id);
          }
        );
        await installAllPluginsInGroup(modal, plugins, enable);
      } else {
        console.error("this file is not a JSON list.");
      }
    } catch (erreur) {
      console.error("Error reading JSON file: ", erreur);
    }
  }
}
async function getPluginsList(modal, enable = false) {
  const installed = getInstalled();
  let filePath = window.electron.remote.dialog.showSaveDialogSync({
    title: "Save installed plugins list as JSON",
    filters: [{ name: "JSON Files", extensions: ["json"] }]
  });
  if (filePath && filePath.length) {
    try {
      const jsonContent = JSON.stringify(installed, null, 2);
      (0, import_fs.writeFileSync)(filePath, jsonContent);
      new import_obsidian4.Notice(`${filePath} created`, 2500);
    } catch (error) {
      console.error("Error saving JSON file:", error);
    }
  }
}
async function installPluginFromOtherVault(modal, enable = false) {
  let dirPath = window.electron.remote.dialog.showOpenDialogSync({
    title: "Select your vault directory, you want plugins list from",
    properties: ["openDirectory"]
  });
  if (dirPath && dirPath.length) {
    const vaultPath = dirPath[0];
    const obsidianPath = path.join(vaultPath, ".obsidian");
    if (!(0, import_fs.existsSync)(obsidianPath)) {
      new import_obsidian4.Notice("Select a vault folder!", 2500);
      return;
    }
    const selectedVaultName = path.basename(vaultPath);
    const currentVaultName = modal.app.vault.getName();
    if (selectedVaultName === currentVaultName) {
      new import_obsidian4.Notice("You have selected the current vault!", 2500);
      return;
    }
    const pluginsPath = path.join(obsidianPath, "plugins");
    if (!(0, import_fs.existsSync)(pluginsPath)) {
      new import_obsidian4.Notice(
        "This vault doesn't contain any installed plugin!",
        2500
      );
      return;
    }
    const installedPlugins = [];
    const pluginFolders = (0, import_fs.readdirSync)(pluginsPath);
    for (const pluginFolder of pluginFolders) {
      const pluginFolderPath = path.join(pluginsPath, pluginFolder);
      const packageJsonPath = path.join(pluginFolderPath, "package.json");
      const manifestJsonPath = path.join(
        pluginFolderPath,
        "manifest.json"
      );
      const mainJsPath = path.join(pluginFolderPath, "main.js");
      if ((0, import_fs.existsSync)(packageJsonPath)) {
        continue;
      }
      if ((0, import_fs.existsSync)(manifestJsonPath) && (0, import_fs.existsSync)(mainJsPath)) {
        const manifestContent = (0, import_fs.readFileSync)(manifestJsonPath, "utf-8");
        const manifestData = JSON.parse(manifestContent);
        const pluginId = manifestData.id;
        installedPlugins.push(pluginId);
      }
    }
    if (!installedPlugins.length) {
      new import_obsidian4.Notice("Found no plugin to install", 2500);
      return;
    }
    const plugins = Object.keys(modal.plugin.settings.commPlugins).filter((id) => {
      return installedPlugins.includes(id);
    });
    await installAllPluginsInGroup(modal, plugins, enable);
  }
}

// src/translate.ts
var import_obsidian5 = require("obsidian");
function canTranslate() {
  return this.plugin.translator && this.plugin.translator.valid;
}
async function translate(text, from) {
  let to = "";
  const plugin = this.app.plugins.plugins.translate;
  if (!plugin) {
    new import_obsidian5.Notice(
      "install obsidian-translate and select a translator"
    );
    return;
  }
  if (!canTranslate) {
    new import_obsidian5.Notice("translator not valid. check your settings", 4e3);
    return;
  }
  const loaded_settings = await plugin.loadData();
  if (loaded_settings.target_language_preference === "last") {
    to = loaded_settings.last_used_target_languages[0];
  } else if (loaded_settings.target_language_preference === "specific") {
    to = loaded_settings.default_target_language;
  } else if (loaded_settings.target_language_preference === "display") {
    to = plugin.current_language;
  }
  return plugin.translator.translate(text, from, to);
}
async function translation(selectedContent) {
  const translated = await translate(selectedContent, "en");
  if (!translated)
    return;
  const translation2 = translated.translation;
  if (!translation2) {
    new import_obsidian5.Notice("translator not valid. check your settings", 4e3);
    return;
  }
  new TranslateModal(this.app, translation2).open();
}
var TranslateModal = class extends import_obsidian5.Modal {
  constructor(app, message) {
    super(app);
    this.message = message;
    this.modalEl.addClass("translate-modal");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const lines = this.message.split("\n");
    lines.forEach((line) => contentEl.createEl("p").setText(line));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/secondary_modals.ts
var DescriptionModal = class extends import_obsidian6.Modal {
  constructor(app, plugin, pluginItem) {
    super(app);
    this.plugin = plugin;
    this.pluginItem = pluginItem;
    this.plugin = plugin;
    this.pluginItem = pluginItem;
  }
  onOpen() {
    const { contentEl, pluginItem } = this;
    contentEl.empty();
    contentEl.createEl("p", {
      text: pluginItem.name + " - v" + pluginItem.version
    }).createEl("p", {
      text: "author: " + pluginItem.author + ", url: " + (pluginItem.authorUrl ? "" : "null")
    }).createEl("a", {
      text: pluginItem.authorUrl,
      href: pluginItem.authorUrl
    });
    contentEl.createEl("p", { text: pluginItem.description });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmModal = class extends import_obsidian6.Modal {
  constructor(app, message, callback, width, height) {
    super(app);
    this.message = message;
    this.callback = callback;
    this.width = width;
    this.height = height;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.width) {
      this.modalEl.style.width = `${this.width}px`;
    }
    if (this.height) {
      this.modalEl.style.height = `${this.height}px`;
    }
    contentEl.createEl("p").setText(this.message);
    new import_obsidian6.Setting(this.contentEl).addButton((b) => {
      b.setIcon("checkmark").setCta().onClick(() => {
        this.callback(true);
        this.close();
      });
    }).addExtraButton(
      (b) => b.setIcon("cross").onClick(() => {
        this.callback(false);
        this.close();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
async function openConfirmModal(app, message, width, height) {
  return await new Promise((resolve) => {
    new ConfirmModal(
      app,
      message,
      (confirmed) => {
        resolve(confirmed);
      },
      width != null ? width : void 0,
      height != null ? height : void 0
    ).open();
  });
}
async function confirm(message, width, height) {
  return await openConfirmModal(
    this.app,
    message,
    width != null ? width : void 0,
    height != null ? height : void 0
  );
}
var ReadMeModal = class extends import_obsidian6.Modal {
  constructor(app, modal, pluginItem) {
    super(app);
    this.modal = modal;
    this.pluginItem = pluginItem;
    this.scope = new import_obsidian6.Scope(this.app.scope);
    this.modal = modal;
    this.pluginItem = pluginItem;
    this.modalEl.addClass("read-me-modal");
    this.comp = new import_obsidian6.Component();
    this.comp.load();
  }
  async onOpen() {
    const { contentEl, pluginItem } = this;
    contentEl.empty();
    const id = pluginItem.id;
    contentEl.createEl("p", {
      text: pluginItem.name,
      cls: "readme-title"
    }).createEl("p", {
      text: "By: " + pluginItem.author
    });
    const openRepo = contentEl.createDiv();
    new import_obsidian6.ButtonComponent(openRepo).setButtonText("GitHub Repo").onClick(async () => {
      await openGitHubRepo(this.modal, pluginItem);
    });
    const divButtons = contentEl.createDiv({ cls: "read-me-buttons" });
    if (!isInstalled(id)) {
      new import_obsidian6.ButtonComponent(divButtons).setButtonText("Install").setCta().onClick(async () => {
        const manifest = await getManifest(this.modal, id);
        if (!manifest) {
          new import_obsidian6.Notice(`Manifest ${id} not found`, 2500);
          return;
        }
        const lastVersion = manifest.version;
        await this.app.plugins.installPlugin(pluginItem.repo, lastVersion != null ? lastVersion : "", manifest);
        new import_obsidian6.Notice(`${pluginItem.name} installed`, 2500);
        await this.onOpen();
        await reOpenModal(this.modal);
      });
    } else {
      const manifests = this.app.plugins.manifests || {};
      let condition;
      if (!isEnabled(this.modal, manifests[pluginItem.id].id)) {
        new import_obsidian6.ButtonComponent(divButtons).setButtonText("Enable").onClick(async () => {
          await this.modal.app.plugins.enablePluginAndSave(pluginItem.id);
          await this.onOpen();
          this.modal.plugin.installedUpdate();
          new import_obsidian6.Notice(`${pluginItem.name} enabled`, 2500);
          await reOpenModal(this.modal);
        });
      } else {
        const pluginSettings = this.modal.app.setting.openTabById(pluginItem.id);
        if (pluginSettings) {
          new import_obsidian6.ButtonComponent(divButtons).setButtonText("Options").onClick(async () => {
            await openPluginSettings(
              this.modal,
              pluginItem
            );
          });
        }
        condition = await getHkeyCondition(this.modal, pluginItem);
        if (condition) {
          new import_obsidian6.ButtonComponent(divButtons).setButtonText("Hotkeys").onClick(async () => {
            await showHotkeysFor(this.modal, pluginItem);
          });
        }
        if (id !== "quick-plugin-switcher")
          new import_obsidian6.ButtonComponent(divButtons).setButtonText("Disable").onClick(async () => {
            await this.modal.app.plugins.disablePluginAndSave(pluginItem.id);
            await this.onOpen();
            new import_obsidian6.Notice(`${pluginItem.name} disabled`, 2500);
            await reOpenModal(this.modal);
          });
      }
      if (id !== "quick-plugin-switcher")
        new import_obsidian6.ButtonComponent(divButtons).setButtonText("Uninstall").onClick(async () => {
          await this.modal.app.plugins.uninstallPlugin(
            pluginItem.id
          );
          await this.onOpen();
          new import_obsidian6.Notice(`${pluginItem.name} uninstalled`, 2500);
          await reOpenModal(this.modal);
        });
    }
    const div = contentEl.createDiv({ cls: "qps-read-me" });
    const data = await getReadMe(pluginItem);
    if (!data) {
      Console.log("pluginItem", pluginItem);
      return;
    }
    const decoder = new TextDecoder("utf-8");
    const content = decoder.decode(base64ToUint8Array(data.content));
    const updatedContent = modifyGitHubLinks(content, pluginItem);
    await import_obsidian6.MarkdownRenderer.render(this.app, updatedContent, div, "/", this.comp);
    this.modalEl.addEventListener("mousemove", (event) => {
      this.mousePosition = { x: event.clientX, y: event.clientY };
    });
    this.scope.register(["Ctrl"], "t", async () => {
      const selectedContent = getSelectedContent();
      if (!selectedContent) {
        new import_obsidian6.Notice("no selection", 4e3);
        return;
      }
      await translation(selectedContent);
    });
    this.modalEl.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      const selectedContent = getSelectedContent();
      if (selectedContent) {
        const menu = new import_obsidian6.Menu();
        menu.addItem(
          (item) => item.setTitle("Copy Ctrl+C").onClick(async () => {
            await navigator.clipboard.writeText(selectedContent);
          })
        );
        menu.addItem(
          (item) => item.setTitle("translate Ctrl+T").onClick(async () => {
            await translation(selectedContent);
          })
        );
        menu.showAtPosition(this.mousePosition);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.comp.unload();
  }
};

// src/modal_components.ts
var import_obsidian7 = require("obsidian");
var mostSwitchedResetButton = (modal, contentEl) => {
  const { settings } = modal.plugin;
  const { filters, installed } = settings;
  if (filters === Filters.MostSwitched && Object.keys(installed).some(
    (id) => installed[id].switched !== 0
  )) {
    new import_obsidian7.ExtraButtonComponent(contentEl).setIcon("reset").setTooltip("Reset mostSwitched values").onClick(async () => {
      reset(modal);
      await reOpenModal(modal);
    });
  }
};
async function addSearch(modal, contentEl, placeholder) {
  const { plugin } = modal;
  const { settings } = plugin;
  new import_obsidian7.Setting(contentEl).addSearch(async (search) => {
    search.setValue(settings.search).setPlaceholder(placeholder).onChange(async (value) => {
      if (modal.searchTyping) {
        settings.search = value;
        modal.items.empty();
        modal.addItems(value);
      }
    });
  }).setClass("qps-search-component");
}
function doSearchQPS(modal, value, plugins) {
  const lowerCaseValue = value.toLowerCase();
  const { byAuthor } = modal.plugin.settings;
  return Object.keys(plugins).filter((id) => {
    const { name, author } = plugins[id];
    const list = byAuthor ? [name, author] : [name];
    return list.some((prop) => prop.toLowerCase().includes(lowerCaseValue));
  });
}
function doSearchCPM(value, commPlugins) {
  const lowerCaseValue = value.toLowerCase();
  const pluginsList = Object.keys(commPlugins);
  return pluginsList.filter(
    (item) => [commPlugins[item].name, commPlugins[item].description, commPlugins[item].author].some((prop) => prop.toLowerCase().includes(lowerCaseValue))
  );
}
var Check4UpdatesButton = (modal, el) => {
  const { plugin } = modal;
  const button = new import_obsidian7.ButtonComponent(el).setIcon("rocket").setCta();
  const toUpdate = Object.values(modal.plugin.settings.installed).filter((item) => item["toUpdate"]);
  if (toUpdate.length)
    button.setClass("red");
  button.setClass("update-button").setTooltip(
    "Search for updates"
  ).buttonEl.addEventListener("click", async (evt) => {
    if (toUpdate.length) {
      const menu = new import_obsidian7.Menu();
      menu.addItem(
        (item) => item.setTitle("Update plugin(s)").setIcon("book-copy").onClick(async () => {
          toUpdate.map((item2) => {
            item2["toUpdate"] = false;
            updatePlugin(modal, item2, plugin.settings.commPlugins);
          });
        })
      );
      menu.addItem(
        (item) => item.setTitle("Search for updates again").setIcon("rocket").onClick(async () => {
          searchUpdates(modal);
        })
      );
      menu.showAtMouseEvent(evt);
    } else {
      searchUpdates(modal);
    }
  });
};
var checkbox = (modal, contentEl, text) => {
  const { plugin } = modal;
  const { settings } = plugin;
  if (modal instanceof QPSModal && settings.filters === Filters.ByGroup || modal instanceof CPModal && settings.filtersComm === CommFilters.ByGroup)
    return;
  const isQPS = modal instanceof QPSModal;
  contentEl.createDiv({ text, cls: "qps-comm-invert" }, (el) => {
    el.createEl(
      "input",
      {
        attr: {
          cls: "qps-invert-button",
          type: "checkbox",
          checked: isQPS ? settings.byAuthor : settings.invertFiltersComm
        }
      },
      (checkbox2) => {
        checkbox2.checked = isQPS ? settings.byAuthor : settings.invertFiltersComm, checkbox2.onchange = () => {
          isQPS ? settings.byAuthor = checkbox2.checked : settings.invertFiltersComm = checkbox2.checked;
          plugin.saveSettings();
          reOpenModal(modal);
        };
      }
    );
  });
};
async function searchUpdates(modal) {
  const { installed, commPlugins } = modal.plugin.settings;
  let open = false;
  let count = 0;
  for (const item of Object.values(installed)) {
    if (item.id === "quick-plugin-switcher" || !(item.id in commPlugins))
      continue;
    const manifest = await getManifest(modal, item.id);
    if (!manifest)
      continue;
    const lastVersion = manifest.version;
    if (!lastVersion || lastVersion <= item.version) {
      item["toUpdate"] = false;
      if (lastVersion && lastVersion <= item.version)
        open = true;
    } else {
      if (lastVersion > item.version) {
        count += 1;
        open = true;
        item["toUpdate"] = true;
      }
    }
  }
  if (open) {
    new import_obsidian7.Notice(`${count} plugins to update`, 3e3);
    await reOpenModal(modal);
  } else {
    new import_obsidian7.Notice("All plugins are up to date");
  }
}
var vertDotsButton = (el) => {
  new import_obsidian7.ButtonComponent(el).setButtonText("\u2807").setTooltip(
    "open context-menu"
  );
};
var commButton = (modal, el) => {
  const { plugin } = modal;
  new import_obsidian7.ButtonComponent(el).setIcon("download-cloud").setCta().setClass("comm-button").setTooltip(
    "community plugins: you can tag plugins with groups, install by group..."
  ).buttonEl.addEventListener("click", async (evt) => {
    await plugin.exeAfterDelay(plugin.pluginsCommInfo.bind(plugin));
    new CPModal(modal.app, plugin).open();
    modal.close();
  });
};
var commOptionButton = (modal, el) => {
  const { plugin } = modal;
  new import_obsidian7.ButtonComponent(el).setIcon("list-end").setCta().setTooltip(
    "Install & enable plugins based on another Vault content or from a JSON list"
  ).buttonEl.addEventListener("click", (evt) => {
    const menu = new import_obsidian7.Menu();
    menu.addItem(
      (item) => item.setTitle("Install plugins based on another Vault").setIcon("book-copy").onClick(async () => {
        await installPluginFromOtherVault(modal);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Install & enable plugins based on another Vault").setIcon("book-copy").onClick(async () => {
        await installPluginFromOtherVault(modal, true);
      })
    );
    menu.addSeparator();
    menu.addItem(
      (item) => item.setTitle("Save installed plugins list").setIcon("pen-square").onClick(async () => {
        await getPluginsList(modal, true);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Install & enable plugins from json list").setIcon("list").onClick(async () => {
        await installFromList(modal, true);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Install plugins from json list").setIcon("list").onClick(async () => {
        await installFromList(modal);
      })
    );
    menu.showAtMouseEvent(evt);
  });
};
var powerButton = (modal, el) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed } = settings;
  new import_obsidian7.ButtonComponent(el).setIcon("power").setCta().setTooltip(
    "toggle plugins: you can disable some plugins and enable them later"
  ).buttonEl.addEventListener("click", (evt) => {
    const menu = new import_obsidian7.Menu();
    if (plugin.lengthEnabled === 1 && settings.wasEnabled.length === 0) {
      menu.addItem((item) => item.setTitle("No enabled plugins"));
    } else {
      menu.addItem(
        (item) => item.setTitle(
          settings.wasEnabled.length > 0 ? "Enable previous disabled plugins" : "Disable all plugins"
        ).setIcon(
          settings.wasEnabled.length > 0 ? "power" : "power-off"
        ).onClick(async () => {
          if (plugin.lengthEnabled > 1) {
            for (const id in installed) {
              if (id === "quick-plugin-switcher")
                continue;
              if (installed[id].enabled)
                settings.wasEnabled.push(id);
              await modal.app.plugins.disablePluginAndSave(id);
              installed[id].enabled = false;
            }
            plugin.getLength();
            await reOpenModal(modal);
            new import_obsidian7.Notice("All plugins disabled", 2500);
          } else if (settings.wasEnabled.length > 0) {
            for (const i of settings.wasEnabled) {
              const toUpdate = Object.keys(installed).find(
                (id) => id === i
              );
              if (toUpdate) {
                await conditionalEnable(
                  modal,
                  toUpdate
                );
                installed[toUpdate].enabled = true;
              }
            }
            plugin.getLength();
            await reOpenModal(modal);
            settings.wasEnabled = [];
            new import_obsidian7.Notice("All plugins re-enabled", 2500);
            await modal.plugin.saveSettings();
          }
        })
      );
      if (settings.wasEnabled.length > 0) {
        menu.addItem(
          (item) => item.setTitle("Skip re-enable").setIcon("reset").onClick(async () => {
            const confirmReset = await confirm(
              "reset to disable",
              300
            );
            if (confirmReset) {
              settings.wasEnabled = [];
              await modal.plugin.saveSettings();
              new import_obsidian7.Notice("Done", 2500);
            } else {
              new import_obsidian7.Notice("Operation cancelled", 2500);
            }
          })
        );
      }
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle("Toggle enabled-plugins by group").setDisabled(true)
      );
      Object.keys(Groups).forEach((groupKey) => {
        if (groupKey === "SelectGroup")
          return;
        const groupValue = Groups[groupKey];
        const groupIndex = getIndexFromSelectedGroup(groupKey);
        const inGroup = Object.keys(installed).filter((id) => {
          return installed[id].groupInfo.groupIndices.indexOf(
            groupIndex
          ) !== -1;
        });
        let previousWasEnabled = inGroup.filter(
          (id) => installed[id].groupInfo.groupWasEnabled === true
        );
        if (inGroup.length > 0 && (inGroup.some((id) => installed[id].enabled === true) || previousWasEnabled.length > 0)) {
          menu.addItem(
            (item) => item.setTitle(
              previousWasEnabled.length > 0 ? `Re-enable ${groupValue}` : groupValue
            ).setIcon(
              previousWasEnabled.length > 0 ? "power" : "power-off"
            ).onClick(async () => {
              if (previousWasEnabled.length === 0) {
                const toDisable = inGroup.filter((id) => installed[id].enabled === true).map(async (id) => {
                  installed[id].groupInfo.groupWasEnabled = true;
                  await modal.app.plugins.disablePluginAndSave(id);
                  installed[id].enabled = false;
                });
                await Promise.all(toDisable);
                if (toDisable) {
                  plugin.getLength();
                  await reOpenModal(modal);
                  new import_obsidian7.Notice(
                    "All plugins disabled",
                    2500
                  );
                }
              } else {
                for (const id of previousWasEnabled) {
                  await conditionalEnable(modal, id);
                  installed[id].enabled = true;
                  installed[id].switched++;
                }
                previousWasEnabled.map((id) => {
                  installed[id].groupInfo.groupWasEnabled = false;
                });
                plugin.getLength();
                await reOpenModal(modal);
                new import_obsidian7.Notice(
                  "All plugins re-enabled",
                  2500
                );
              }
            })
          );
          if (previousWasEnabled.length > 0) {
            menu.addItem(
              (item) => item.setTitle("Skip re-enable").setIcon("reset").onClick(async () => {
                const confirmReset = await confirm(
                  "skip re-enable ?",
                  200
                );
                if (confirmReset) {
                  previousWasEnabled.map((id) => {
                    installed[id].groupInfo.groupWasEnabled = false;
                  });
                  await modal.plugin.saveSettings();
                  new import_obsidian7.Notice("Done", 2500);
                } else {
                  new import_obsidian7.Notice(
                    "Operation cancelled",
                    2500
                  );
                }
              })
            );
          }
        }
      });
    }
    menu.showAtMouseEvent(evt);
  });
};
var itemToggleClass = (modal, pluginItem, itemContainer) => {
  const { settings } = modal.plugin;
  if (pluginItem.id === "quick-plugin-switcher") {
    itemContainer.toggleClass("qps-quick-plugin-switcher", true);
  }
  if (pluginItem.isDesktopOnly === true) {
    itemContainer.addClass("qps-desktop-only");
  }
  if (pluginItem.hasOwnProperty("toUpdate") && pluginItem.toUpdate === true) {
    itemContainer.toggleClass("qps-update", true);
  }
  if (settings.filters === Filters.MostSwitched && pluginItem.switched !== 0) {
    itemContainer.toggleClass("qps-most-switched", true);
  }
  if (pluginItem.delayed) {
    itemContainer.toggleClass("toggle-bullet-color", true);
    itemContainer.style.setProperty(
      "--bullet-content",
      `"${pluginItem.time}"`
    );
  }
};
var itemTextComponent = (pluginItem, itemContainer) => {
  let customValue = pluginItem.name;
  if (pluginItem.isDesktopOnly) {
    customValue = "\u1D30" + customValue;
  }
  customValue = customValue + `|${pluginItem.version}`;
  let text = new import_obsidian7.TextComponent(itemContainer).setValue(customValue);
  const input = text.inputEl;
  input.readOnly = true;
  return input;
};
var pluginFeatureSubmenu = async (submenu, pluginItem, modal) => {
  const { settings } = modal.plugin;
  const { installed } = settings;
  const id = pluginItem.id;
  submenu.addItem(
    (item) => item.setTitle("Short info (i)").setIcon("text").onClick(() => {
      new DescriptionModal(
        modal.plugin.app,
        modal.plugin,
        installed[id]
      ).open();
    })
  );
  submenu.addItem(
    (item) => item.setTitle("Plugin github (g)").setIcon("github").onClick(async () => {
      await openGitHubRepo(modal, installed[id]);
    })
  );
  const pluginSettings = modal.app.setting.openTabById(
    id
  );
  submenu.addSeparator();
  submenu.addItem(
    (item) => item.setTitle("Plugin settings (s)").setIcon("settings").setDisabled(!pluginSettings).onClick(async () => {
      await openPluginSettings(modal, pluginItem);
    })
  );
  const condition = await getHkeyCondition(modal, pluginItem);
  submenu.addItem(
    (item) => item.setTitle("Modify hotkeys (h)").setIcon("plus-circle").setDisabled(!condition).onClick(async () => {
      await showHotkeysFor(modal, pluginItem);
    })
  );
};
var getHkeyCondition = async function(modal, item) {
  var _a, _b;
  const pluginCommands = await ((_b = (_a = modal.app.setting.openTabById(
    "command-palette"
  )) == null ? void 0 : _a.app) == null ? void 0 : _b.commands.commands);
  return hasKeyStartingWith(pluginCommands, item.id);
};
var openGitHubRepo = async (modal, plugin) => {
  var _a;
  let repo;
  if ("repo" in plugin) {
    repo = plugin.repo;
  } else {
    const key = plugin.id;
    const { commPlugins } = modal.plugin.settings;
    const matchingPlugin = Object.values(commPlugins).find(
      (plugin2) => plugin2.id === key
    );
    repo = (_a = matchingPlugin == null ? void 0 : matchingPlugin.repo) != null ? _a : "";
  }
  const repoURL = `https://github.com/${repo}`;
  window.open(repoURL, "_blank");
};
var searchDivButtons = (modal, contentEl) => {
  const span = contentEl.createEl(
    "span",
    {
      cls: "qps-toggle-plugins"
    },
    (el) => {
      powerButton(modal, el);
      commButton(modal, el);
      Check4UpdatesButton(modal, el);
    }
  );
};
var searchCommDivButton = (modal, contentEl) => {
  const span = contentEl.createEl(
    "span",
    {
      cls: "qps-toggle-plugins"
    },
    (el) => {
      commOptionButton(modal, el);
    }
  );
};
async function hideOnCLick(modal, groupNumber, inGroup) {
  var _a;
  const { plugin } = modal;
  const { settings } = plugin;
  const { groups, groupsComm, installed, commPlugins } = settings;
  if (modal instanceof QPSModal) {
    if (groups[groupNumber]) {
      if (!groups[groupNumber].hidden && !inGroup.length) {
        new import_obsidian7.Notice("empty group", 3e3);
        return;
      }
      groups[groupNumber].hidden = !groups[groupNumber].hidden;
    }
    inGroup.forEach((id) => {
      if (groups[groupNumber].hidden)
        installed[id].groupInfo.hidden = true;
      else {
        let prevent = false;
        for (const i of installed[id].groupInfo.groupIndices) {
          if (groups[i].hidden)
            prevent = true;
        }
        if (!prevent)
          installed[id].groupInfo.hidden = false;
      }
    });
  } else {
    if (groupsComm[groupNumber]) {
      if (!groupsComm[groupNumber].hidden && !inGroup.length) {
        new import_obsidian7.Notice("empty group", 3e3);
        return;
      }
      groupsComm[groupNumber].hidden = !((_a = groupsComm[groupNumber]) == null ? void 0 : _a.hidden);
    }
    inGroup.forEach((id) => {
      if (groupsComm[groupNumber].hidden)
        commPlugins[id].groupCommInfo.hidden = true;
      else {
        let prevent = false;
        for (const i of commPlugins[id].groupCommInfo.groupIndices) {
          if (groupsComm[i].hidden)
            prevent = true;
        }
        if (!prevent) {
          commPlugins[id].groupCommInfo.hidden = false;
        }
      }
    });
  }
  await reOpenModal(modal);
}
async function handleClick(evt, modal) {
  const elementFromPoint = getElementFromMousePosition(modal);
  const targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".button-container"
  );
  if (targetBlock) {
    const matchingItem = findMatchingItem(modal, targetBlock.parentElement);
    if (matchingItem) {
      if (modal instanceof QPSModal) {
        await contextMenuQPS(evt, modal, matchingItem);
      } else {
        contextMenuCPM(evt, modal, matchingItem);
      }
    }
  }
}
function handleDblClick(evt, modal) {
  const elementFromPoint = getElementFromMousePosition(modal);
  const targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-comm-block"
  );
  const targetGroup = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-groups-name"
  );
  const pluginItemBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-item-line input"
  );
  const targetGroupIcon = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-circle-title-group"
  );
  if (targetBlock) {
    const matchingItem = findMatchingItem(modal, targetBlock);
    if (matchingItem) {
      new ReadMeModal(
        modal.plugin.app,
        modal,
        matchingItem
      ).open();
    }
  }
  if (pluginItemBlock) {
    const matchingItem = findMatchingItem(modal, pluginItemBlock);
    if (matchingItem) {
      handleInputDblClick(modal, pluginItemBlock, matchingItem);
    }
  }
  if (targetGroup) {
    const groupName = targetGroup == null ? void 0 : targetGroup.textContent;
    const groupNumber = groupNbFromGrpName(groupName);
    editGroupName(modal, targetGroup, groupNumber);
  }
  if (targetGroupIcon && modal instanceof QPSModal) {
    const groupNumber = groupNbFromEmoticon(targetGroupIcon);
    const inGroup = getPluginsInGroup(modal, groupNumber);
    addDelayToGroup(modal, groupNumber, targetGroupIcon, inGroup);
  }
}
var handleInputDblClick = async (modal, itemContainer, pluginItem) => {
  if (pluginItem.id === "quick-plugin-switcher")
    return;
  const currentValue = pluginItem.time.toString();
  modal.isDblClick = true;
  if (!itemContainer) {
    return;
  }
  const input = createInput(itemContainer, currentValue);
  if (!pluginItem.delayed) {
    if (input) {
      const setDelay = () => {
        setTimeout(async () => {
          await modal.addDelay(pluginItem.id, input);
          modal.isDblClick = false;
        }, 100);
      };
      input.onkeydown = (event) => {
        if (event.key === "Enter") {
          setDelay();
        }
      };
      input.onblur = setDelay;
    }
  } else {
    pluginItem.delayed = false;
    await modal.app.plugins.enablePluginAndSave(pluginItem.id);
    modal.isDblClick = false;
    await reOpenModal(modal);
  }
};
async function handleContextMenu(evt, modal) {
  const elementFromPoint = getElementFromMousePosition(modal);
  let targetBlock, targetGroup;
  targetGroup = elementFromPoint == null ? void 0 : elementFromPoint.closest(".qps-groups-name");
  const groupName = targetGroup == null ? void 0 : targetGroup.textContent;
  const groupNumber = groupNbFromGrpName(groupName);
  if (targetGroup) {
    await groupMenu(evt, modal, groupNumber, targetGroup);
    return;
  }
  if (modal instanceof QPSModal) {
    targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
      ".qps-item-line"
    );
  } else {
    targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
      ".qps-comm-block"
    );
  }
  if (targetBlock) {
    const matchingItem = findMatchingItem(modal, targetBlock);
    if (matchingItem) {
      if (modal instanceof QPSModal) {
        if (!modal.app.isMobile) {
          await contextMenuQPS(evt, modal, matchingItem);
        }
      } else {
        contextMenuCPM(evt, modal, matchingItem);
      }
    }
  }
}
function contextMenuCPM(evt, modal, matchingItem) {
  evt.preventDefault();
  const menu = new import_obsidian7.Menu();
  const { settings } = modal.plugin;
  const { installed } = settings;
  const id = matchingItem.id;
  menu.addItem((item) => {
    item.setTitle("Install plugin").setDisabled(isInstalled(id) || id === "quick-plugin-switcher").setIcon("log-in").onClick(async () => {
      const manifest = await getManifest(modal, id);
      if (!manifest) {
        new import_obsidian7.Notice(`Manifest ${id} not found`, 2500);
        return;
      }
      const lastVersion = manifest.version;
      await this.app.plugins.installPlugin(matchingItem.repo, lastVersion, manifest);
      await reOpenModal(modal);
    });
  });
  menu.addItem((item) => {
    const isenabled = isEnabled(modal, id);
    item.setTitle(isenabled ? "Disable plugin" : "Enable plugin").setDisabled(!isInstalled(id) || id === "quick-plugin-switcher").setIcon(isenabled ? "poweroff" : "power").onClick(async () => {
      isEnabled(modal, id) ? await modal.app.plugins.disablePluginAndSave(id) : await modal.app.plugins.enablePluginAndSave(id);
      const msg = isenabled ? "disabled" : "enabled";
      new import_obsidian7.Notice(`${matchingItem.name} ${msg}`, 2500);
      reOpenModal(modal);
    });
  });
  menu.addItem((item) => {
    item.setTitle("Uninstall plugin").setDisabled(!isInstalled(id) || id === "quick-plugin-switcher").setIcon("log-out").onClick(async () => {
      await this.app.plugins.uninstallPlugin(id);
      new import_obsidian7.Notice(`${matchingItem.name} uninstalled`, 2500);
      await reOpenModal(modal);
    });
  });
  if (this.app.isMobile) {
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Plugin github (g)").setIcon("github").onClick(async () => {
        await openGitHubRepo(modal, matchingItem);
      });
    });
    menu.addSeparator();
    addToGroupSubMenu(menu, matchingItem, modal, true);
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Remove All groups").setDisabled(
        matchingItem.groupCommInfo.groupIndices.length === 0
      ).onClick(async () => {
        await rmvAllGroupsFromPlugin(modal, matchingItem);
      });
    });
    addRemoveItemGroupMenuItems(modal, menu, matchingItem, true);
  }
  menu.showAtMouseEvent(evt);
}
async function contextMenuQPS(evt, modal, matchingItem) {
  const { plugin } = modal;
  const menu = new import_obsidian7.Menu();
  if (!this.app.isMobile) {
    menu.addItem(
      (item) => item.setTitle("Plugin folder (f)").setIcon("folder-open").onClick(async () => {
        await openDirectoryInFileManager(modal, matchingItem);
      })
    );
  }
  if (!this.app.isMobile) {
    menu.addItem(async (item) => {
      item.setTitle("Plugin features").setIcon("package-plus");
      const submenu = item.setSubmenu();
      await pluginFeatureSubmenu(submenu, matchingItem, modal);
    });
  } else {
    await pluginFeatureSubmenu(menu, matchingItem, modal);
  }
  if (isInstalled(matchingItem.id)) {
    menu.addSeparator();
    menu.addItem((item) => {
      const { commPlugins } = plugin.settings;
      item.setTitle("Update plugin!").setDisabled(matchingItem.id === "quick-plugin-switcher").setIcon("rocket").onClick(async () => {
        updatePlugin(modal, matchingItem, commPlugins);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Uninstall plugin").setDisabled(matchingItem.id === "quick-plugin-switcher").setIcon("log-out").onClick(async () => {
        await this.app.plugins.uninstallPlugin(matchingItem.id);
        new import_obsidian7.Notice(`${matchingItem.name} uninstalled`, 2500);
        await modal.plugin.installedUpdate();
        await reOpenModal(modal);
      });
    });
  }
  if (matchingItem.id !== "quick-plugin-switcher") {
    menu.addSeparator();
    if (!this.app.isMobile) {
      menu.addItem((item) => {
        item.setTitle("Add to group").setIcon("user");
        const submenu = item.setSubmenu();
        addToGroupSubMenu(submenu, matchingItem, modal);
      });
    } else {
      addToGroupSubMenu(menu, matchingItem, modal, true);
    }
    if (!this.app.isMobile) {
      menu.addItem((item) => {
        item.setTitle("Remove from group").setIcon("user-minus");
        const submenu = item.setSubmenu();
        submenu.addItem((subitem) => {
          subitem.setTitle("All groups").setDisabled(
            matchingItem.groupInfo.groupIndices.length === 0
          ).onClick(async () => {
            await rmvAllGroupsFromPlugin(modal, matchingItem);
          });
        });
        addRemoveItemGroupMenuItems(modal, submenu, matchingItem);
      });
    } else {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Remove All groups").setDisabled(
          matchingItem.groupInfo.groupIndices.length === 0
        ).onClick(async () => {
          await rmvAllGroupsFromPlugin(modal, matchingItem);
        });
      });
      addRemoveItemGroupMenuItems(modal, menu, matchingItem, true);
    }
  }
  menu.showAtMouseEvent(evt);
}
async function updatePlugin(modal, matchingItem, commPlugins) {
  const { id, version } = matchingItem;
  const manifest = await getManifest(modal, id);
  const hasRelease = await getReleaseVersion(modal, id, manifest);
  const lastVersion = manifest.version;
  if (!(id in commPlugins)) {
    new import_obsidian7.Notice(`Not a published plugin`, 2500);
  } else if (!manifest) {
    new import_obsidian7.Notice(`No manifest in ${commPlugins[id].repo}`, 3500);
  } else if (!hasRelease) {
    new import_obsidian7.Notice(`can't update, version ${manifest.version} in repo has not been released!`);
  } else if (lastVersion <= version) {
    new import_obsidian7.Notice(`Already last version ${lastVersion}`, 2500);
  } else {
    try {
      await modal.app.plugins.installPlugin(commPlugins[id].repo, lastVersion, manifest);
      new import_obsidian7.Notice(`version ${version} updated to ${lastVersion}`, 2500);
      matchingItem.version = lastVersion;
      await modal.plugin.installedUpdate();
    } catch (e) {
      console.error("install failed");
    }
  }
  matchingItem.toUpdate = false;
  await reOpenModal(modal);
}
var findMatchingItem = (modal, targetBlock) => {
  const { installed, commPlugins } = modal.plugin.settings;
  if (modal instanceof QPSModal) {
    let itemName = targetBlock.children[1] ? targetBlock.children[1].value : targetBlock.value;
    if (itemName.startsWith("\u1D30")) {
      itemName = itemName.substring(1);
    }
    itemName = itemName.split("|")[0];
    const matchingItem = Object.keys(installed).find(
      (id) => installed[id].name === itemName
    );
    return installed[matchingItem];
  } else {
    const target = modal.app.isMobile ? targetBlock.children[1] : targetBlock.firstChild;
    const itemName = target == null ? void 0 : target.textContent;
    const cleanItemName = itemName == null ? void 0 : itemName.replace(/installed$/, "").trim();
    const matchingItem = Object.keys(commPlugins).find(
      (id) => commPlugins[id].name === cleanItemName
    );
    return commPlugins[matchingItem];
  }
};
var createClearGroupsMenuItem = (modal, menu, groupNumber) => {
  if (!modal.app.isMobile) {
    menu.addItem((item) => {
      item.setTitle("Clear group(s)").setIcon("user-minus");
      const submenu = item.setSubmenu();
      addRemoveGroupMenuItems(modal, submenu, groupNumber);
      submenu.addSeparator();
      clearAllGroups(submenu, modal);
    });
  } else {
    menu.addItem((item) => {
      item.setTitle("Clear group(s)").setIcon("user-minus");
    });
    addRemoveGroupMenuItems(modal, menu, groupNumber);
    clearAllGroups(menu, modal);
  }
};
function clearAllGroups(submenu, modal) {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed, commPlugins, groups, groupsComm } = settings;
  submenu.addItem((subitem) => {
    subitem.setTitle("All groups").onClick(async () => {
      const confirmReset = await confirm(
        "Detach all groups from all plugins?",
        300
      );
      if (confirmReset) {
        if (modal instanceof QPSModal) {
          for (const id in installed) {
            installed[id].groupInfo.hidden = false;
            installed[id].groupInfo.groupIndices = [];
          }
          for (const group in groups)
            groups[group].hidden = false;
          await reOpenModal(modal);
          new import_obsidian7.Notice(`All groups empty`, 2500);
        } else {
          for (const group in groupsComm)
            groupsComm[group].hidden = false;
          for (const id in commPlugins) {
            commPlugins[id].groupCommInfo.hidden = false;
            commPlugins[id].groupCommInfo.groupIndices = [];
          }
          await reOpenModal(modal);
          new import_obsidian7.Notice(`All groups empty`, 2500);
        }
      } else {
        new import_obsidian7.Notice("Operation cancelled", 2500);
      }
    });
  });
}

// src/main_modal.ts
var QPSModal = class extends import_obsidian8.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.searchTyping = true;
    this.isDblClick = false;
    this.pressed = false;
    this.searchInit = true;
    this.getMousePosition = (event) => {
      this.mousePosition = { x: event.clientX, y: event.clientY };
    };
    this.getHandleKeyDown = async (event) => {
      await handleKeyDown2(event, this);
    };
    this.getHandleContextMenu = async (evt) => {
      if (this.isDblClick)
        return;
      await handleContextMenu(evt, this);
    };
    this.getHandleDblClick = (evt) => {
      if (this.isDblClick)
        return;
      handleDblClick(evt, this);
    };
    this.getHandleClick = (evt) => {
      if (this.isDblClick)
        return;
      handleClick(evt, this);
    };
    this.addHeader = (contentEl) => {
      const { plugin } = this;
      const { settings } = plugin;
      new import_obsidian8.DropdownComponent(contentEl).addOptions({
        all: `All(${plugin.lengthAll})`,
        enabled: `Enabled(${plugin.lengthEnabled})`,
        disabled: `Disabled(${plugin.lengthDisabled})`,
        enabledFirst: `Enabled First(${plugin.lengthAll})`,
        mostSwitched: `Most Switched(${plugin.lengthAll})`,
        byGroup: `By Group`,
        hidden: `Hidden(${getHidden(this).length})`
      }).setValue(settings.filters).onChange(async (value) => {
        settings.filters = value;
        await reOpenModal(this);
      });
      mostSwitchedResetButton(this, contentEl);
      byGroupDropdowns(this, contentEl);
    };
    this.addDelay = async (id, input) => {
      const { plugin } = this;
      const { settings } = plugin;
      const { installed } = settings;
      installed[id].delayed = true;
      installed[id].time = parseInt(input.value) || 0;
      if (installed[id].time === 0) {
        installed[id].delayed = false;
      }
      if (installed[id].delayed && installed[id].enabled) {
        await delayedReEnable(this, id);
      }
      await reOpenModal(this);
    };
    this.plugin = plugin;
  }
  removeListeners() {
    this.modalEl.removeEventListener("mousemove", this.getMousePosition);
    document.removeEventListener("keydown", this.getHandleKeyDown);
    this.modalEl.removeEventListener("contextmenu", this.getHandleContextMenu);
    this.modalEl.removeEventListener("dblclick", this.getHandleDblClick);
    if (this.app.isMobile) {
      this.modalEl.removeEventListener("dblclick", this.getHandleClick);
    }
  }
  container() {
    const { contentEl } = this;
    this.modalEl.addClass("qps-modal");
    this.header = contentEl.createEl("div", {
      cls: "qps-header"
    });
    this.search = contentEl.createEl("div", { cls: "qps-search" });
    this.groups = contentEl.createEl("div", { cls: "qps-groups" });
    this.hotkeysDesc = contentEl.createEl("p", { cls: "qps-hk-desc" });
    this.items = contentEl.createEl("div", { cls: "qps-items" });
    this.modalEl.addEventListener("mousemove", this.getMousePosition);
    document.addEventListener("keydown", this.getHandleKeyDown);
    this.modalEl.addEventListener("contextmenu", this.getHandleContextMenu);
    this.modalEl.addEventListener("dblclick", this.getHandleDblClick);
    if (this.app.isMobile) {
      this.modalEl.addEventListener("click", this.getHandleClick);
    }
  }
  async onOpen() {
    this.removeListeners();
    const { plugin, contentEl } = this;
    const { settings } = plugin;
    if (this.searchInit)
      settings.search = "";
    this.searchInit = true;
    contentEl.empty();
    this.container();
    setGroupTitle(this, Groups, settings.numberOfGroups);
    this.addHeader(this.header);
    await addSearch(this, this.search, "Search plugins");
    checkbox(this, this.search, "+Author");
    searchDivButtons(this, this.search);
    this.addGroups(this.groups);
    if (settings.showHotKeys && !this.app.isMobile)
      this.setHotKeysdesc();
    await this.addItems(settings.search);
  }
  addGroups(contentEl) {
    const groups = Object.values(Groups);
    for (let i = 1; i < groups.length; i++) {
      const groupKey = groups[i];
      contentEl.createEl(
        "span",
        {
          cls: "qps-group-span-container"
        },
        (cont) => {
          cont.createEl(
            "span",
            {
              cls: "qps-circle-title-group"
            },
            (el) => {
              circleCSSModif(this, el, i);
            }
          );
          const span = cont.createEl("span", {
            cls: "qps-groups-name",
            text: `${groupKey}`
          }, (el) => {
            var _a;
            const { plugin } = this;
            const { settings } = plugin;
            const hidden = (_a = settings.groups[i]) == null ? void 0 : _a.hidden;
            if (hidden) {
              el.style.textDecoration = "line-through";
            } else {
              el.style.textDecoration = "none";
            }
          });
          const groupNumberText = `(<span class="shortcut-number">${i}</span>)`;
          span.insertAdjacentHTML("beforeend", groupNumberText);
        }
      );
    }
    if (!this.app.isMobile) {
      contentEl.createSpan({
        text: `> (h)\u{1F441}\uFE0F (\u{1F5B1}\uFE0Fx2)name`
      });
    } else {
      contentEl.createSpan({
        text: `(\u{1F5B1}\uFE0Fx2)name,icon:delay (\u{1F5B1}\uFE0F...)context-menu`
      });
    }
  }
  setHotKeysdesc() {
    const numberOfGroups = this.plugin.settings.numberOfGroups;
    this.hotkeysDesc.createSpan(
      {
        text: `(1-${numberOfGroups})\u2795 (0)\u274C (f)\u{1F4C1} `
      },
      (el) => {
        el.createSpan({ text: "(g)" }, (el2) => {
          let gitHubIcon = el2.createSpan({ cls: "git-hub-icon" });
          (0, import_obsidian8.setIcon)(gitHubIcon, "github");
        });
        el.createSpan({
          text: ` (ctrl)\u2139\uFE0F (s)\u2699\uFE0F (h)\u2328\uFE0F `
        });
        el.createSpan({
          cls: "qps-hk-desc-last-part",
          text: `(\u{1F5B1}\uFE0Fx2)delay`
        });
      }
    );
  }
  async addItems(value) {
    const { plugin } = this;
    const { settings } = plugin;
    const { installed, filters } = settings;
    let listItems = doSearchQPS(this, value, installed);
    listItems = modeSort(this, plugin, listItems);
    for (const id of listItems) {
      if (filters !== Filters.ByGroup && installed[id].groupInfo.hidden === true && filters !== Filters.Hidden) {
        continue;
      }
      if (filters === Filters.Enabled && !installed[id].enabled || filters === Filters.Disabled && installed[id].enabled) {
        continue;
      }
      let itemContainer = this.items.createEl("div", {
        cls: "qps-item-line"
      });
      itemTogglePluginButton(this, installed[id], itemContainer);
      const input = itemTextComponent(installed[id], itemContainer);
      itemToggleClass(this, installed[id], itemContainer);
      addGroupCircles2(input, installed[id]);
      if (this.app.isMobile) {
        const div = itemContainer.createEl(
          "div",
          {
            cls: "button-container"
          },
          (el) => {
            vertDotsButton(el);
          }
        );
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.removeListeners();
  }
};
function circleCSSModif(modal, el, groupIndex) {
  var _a;
  const { color } = getEmojiForGroup(groupIndex);
  el.style.backgroundColor = color;
  if (modal instanceof QPSModal) {
    const { settings } = modal.plugin;
    el.textContent = (((_a = settings.groups[groupIndex]) == null ? void 0 : _a.time) ? settings.groups[groupIndex].time : "").toString();
  }
}
var itemTogglePluginButton = (modal, pluginItem, itemContainer) => {
  let disable = pluginItem.id === "quick-plugin-switcher";
  new import_obsidian8.ToggleComponent(itemContainer).setValue(pluginItem.enabled).setDisabled(disable).onChange(async () => {
    await togglePlugin(modal, pluginItem);
  });
};
var addGroupCircles2 = (input, item) => {
  const indices = item.groupInfo.groupIndices;
  if (!indices.length)
    return;
  if (indices.length < 3) {
    const content = getCirclesItem(indices);
    input.insertAdjacentHTML("afterend", content);
  }
  if (indices.length >= 3 && indices.length < 5) {
    const [valeur0, valeur1, ...part2] = indices;
    const part1 = [valeur0, valeur1];
    const content1 = getCirclesItem(part1);
    input.insertAdjacentHTML("afterend", content1);
    const content2 = getCirclesItem(part2);
    input.insertAdjacentHTML("afterend", content2);
  } else if (indices.length >= 5) {
    const [valeur0, valeur1, valeur2, valeur3, ...part3] = indices;
    const part1 = [valeur0, valeur1];
    const part2 = [valeur2, valeur3];
    const content1 = getCirclesItem(part1);
    input.insertAdjacentHTML("afterend", content1);
    const content2 = getCirclesItem(part2);
    input.insertAdjacentHTML("afterend", content2);
    const content3 = getCirclesItem(part3);
    input.insertAdjacentHTML("afterend", content3);
  }
};
async function handleKeyDown2(event, modal) {
  const elementFromPoint = getElementFromMousePosition(modal);
  const pluginItemBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-item-line"
  );
  const targetGroupIcon = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-circle-title-group"
  );
  const targetGroup = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-groups-name"
  );
  if (pluginItemBlock) {
    modal.searchTyping = false;
    const matchingItem = findMatchingItem(modal, pluginItemBlock);
    if (matchingItem) {
      await handleHotkeysQPS(modal, event, matchingItem);
    }
  } else if ((targetGroupIcon || targetGroup) && event.key === "h") {
    modal.searchTyping = false;
    await toggleVisibility(modal, targetGroupIcon, targetGroup);
  } else {
    modal.searchTyping = true;
  }
}
var toggleVisibility = async (modal, targetGroupIcon, targetGroup) => {
  let groupNumber;
  if (targetGroupIcon) {
    groupNumber = groupNbFromEmoticon(targetGroupIcon);
  } else {
    const groupName = targetGroup == null ? void 0 : targetGroup.textContent;
    groupNumber = groupNbFromGrpName(groupName);
  }
  const inGroup = getPluginsInGroup(modal, groupNumber);
  await hideOnCLick(modal, groupNumber, inGroup);
};
var handleHotkeysQPS = async (modal, evt, pluginItem) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { groups, installed } = settings;
  const numberOfGroups = settings.numberOfGroups;
  const KeyToSettingsMap = {
    g: async () => await openGitHubRepo(modal, pluginItem),
    s: async () => await openPluginSettings(modal, pluginItem),
    h: async () => await showHotkeysFor(modal, pluginItem)
  };
  if (import_obsidian8.Platform.isDesktopApp)
    KeyToSettingsMap["f"] = async () => await openDirectoryInFileManager(modal, pluginItem);
  const keyPressed = evt.key;
  if (!pluginItem.groupInfo) {
    pluginItem.groupInfo = {
      groupIndices: [],
      groupWasEnabled: false,
      hidden: false
    };
    await reOpenModal(modal);
  }
  if (modal.pressed) {
    return;
  }
  pressDelay(modal);
  if (modal.isDblClick)
    return;
  const groupIndices = pluginItem.groupInfo.groupIndices;
  const key = parseInt(keyPressed);
  if (key > 0 && key <= numberOfGroups && !(pluginItem.id === "quick-plugin-switcher")) {
    if (groupIndices.length === 6)
      return;
    const index = groupIndices.indexOf(key);
    if (index === -1) {
      groupIndices == null ? void 0 : groupIndices.push(key);
      if (groups[key].hidden)
        installed[pluginItem.id].groupInfo.hidden = true;
      await reOpenModal(modal);
    }
  } else if (keyPressed in KeyToSettingsMap) {
    KeyToSettingsMap[keyPressed]();
  } else if (evt.metaKey || evt.ctrlKey) {
    new DescriptionModal(plugin.app, plugin, pluginItem).open();
  } else if ((keyPressed === "Delete" || keyPressed === "Backspace" || keyPressed === "0") && !(pluginItem.id === "quick-plugin-switcher")) {
    if (!groupIndices.length)
      return;
    if (groupIndices.length === 1) {
      const groupIndex = groupIndices[0];
      pluginItem.groupInfo.groupIndices = [];
      if (groupIsEmpty(groupIndex, modal)) {
        settings.selectedGroup = "SelectGroup";
      }
      await reOpenModal(modal);
    } else {
      const menu = new import_obsidian8.Menu();
      menu.addItem(
        (item) => item.setTitle("Remove item group(s)").setDisabled(true).setDisabled(true)
      );
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle("All").onClick(async () => {
          await rmvAllGroupsFromPlugin(modal, pluginItem);
        })
      );
      for (const groupIndex of groupIndices) {
        const { emoji } = getEmojiForGroup(groupIndex);
        menu.addItem(
          (item) => item.setTitle(`${emoji} group ${groupIndex}`).onClick(async () => {
            pluginItem.groupInfo.groupIndices = removeItem(
              pluginItem.groupInfo.groupIndices,
              groupIndex
            );
            await reOpenModal(modal);
          })
        );
      }
      menu.showAtPosition(modal.mousePosition);
    }
  }
};

// src/settings.ts
var import_obsidian9 = require("obsidian");
var QPSSettingTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    const { plugin } = this;
    const { settings } = plugin;
    containerEl.empty();
    let saveSettingsTimeout;
    const { numberOfGroups, numberOfGroupsComm } = settings;
    new import_obsidian9.Setting(containerEl).setName("Number of plugins groups").setDesc("To treat plugins by groups").addSlider((slider) => {
      slider.setLimits(1, 6, 1).setValue(numberOfGroups).setDynamicTooltip().onChange(async (value) => {
        if (value < numberOfGroups) {
          clearTimeout(saveSettingsTimeout);
          saveSettingsTimeout = setTimeout(async () => {
            const confirmReset = await confirm(
              "reducing number of groups, higher groups info will be lost",
              350
            );
            if (confirmReset) {
              const { installed } = settings;
              for (const key in installed) {
                let hasValueGreaterThanValue = false;
                for (const groupIndex of installed[key].groupInfo.groupIndices) {
                  if (groupIndex > value) {
                    hasValueGreaterThanValue = true;
                    break;
                  }
                }
                if (hasValueGreaterThanValue) {
                  installed[key].groupInfo.groupIndices = [];
                }
              }
              settings.numberOfGroups = value;
              await plugin.saveSettings();
            } else {
              slider.setValue(numberOfGroups);
            }
          }, 700);
        } else {
          clearTimeout(saveSettingsTimeout);
          settings.numberOfGroups = value;
          await plugin.saveSettings();
        }
        settings.numberOfGroups = value;
        await plugin.saveSettings();
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Number of community plugins groups").setDesc("To treat plugins by groups").addSlider((slider) => {
      slider.setLimits(1, 6, 1).setValue(numberOfGroupsComm).setDynamicTooltip().onChange(async (value) => {
        if (value < numberOfGroupsComm) {
          clearTimeout(saveSettingsTimeout);
          saveSettingsTimeout = setTimeout(async () => {
            const confirmReset = await confirm(
              "reducing number of groups, higher groups info will be lost",
              350
            );
            if (confirmReset) {
              const { commPlugins } = settings;
              for (const key in commPlugins) {
                let hasValueGreaterThanValue = false;
                let groupIndices = commPlugins[key].groupCommInfo.groupIndices;
                if (groupIndices) {
                  for (const groupIndex of groupIndices) {
                    if (groupIndex > value) {
                      hasValueGreaterThanValue = true;
                      break;
                    }
                  }
                }
                if (hasValueGreaterThanValue) {
                  groupIndices = [];
                }
              }
              ;
              settings.numberOfGroupsComm = value;
              await plugin.saveSettings();
            } else {
              slider.setValue(numberOfGroupsComm);
            }
          }, 700);
        } else {
          clearTimeout(saveSettingsTimeout);
          settings.numberOfGroupsComm = value;
          await plugin.saveSettings();
        }
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Show hotkeys line reminder").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showHotKeys).onChange((value) => {
        this.plugin.settings.showHotKeys = value;
        this.plugin.saveSettings();
      });
    });
  }
};

// src/main.ts
var QuickPluginSwitcher = class extends import_obsidian10.Plugin {
  constructor() {
    super(...arguments);
    this.lengthAll = 0;
    this.lengthDisabled = 0;
    this.lengthEnabled = 0;
    this.reset = false;
    this.exeAfterDelay = async (func) => {
      const currentTime = Date.now();
      if (currentTime - this.settings.lastFetchExe >= 12e4) {
        const ret = await func();
        if (ret === true) {
          this.settings.lastFetchExe = currentTime;
          await this.saveSettings();
        } else {
          Console.log("community plugins udpate failed, check your connexion");
        }
      } else {
        Console.log(
          "fetched less than 2 min, community plugins not updated"
        );
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.app.workspace.onLayoutReady(async () => {
      const installed = this.settings.installed || {};
      const manifests = this.app.plugins.manifests || {};
      let stillInstalled = [];
      for (const pluginId in installed) {
        if (pluginId in manifests)
          stillInstalled.push(pluginId);
        else {
          delete installed[pluginId];
        }
      }
      const { wrapper1, wrapper2 } = this.wrapDisableEnablePluginAndSave(
        stillInstalled,
        async () => {
          await this.saveSettings();
        }
      );
      this.register(wrapper1);
      this.register(wrapper2);
      for (const id of stillInstalled) {
        if (isEnabled(this, id) !== installed[id].enabled && !installed[id].delayed) {
          installed[id].enabled = !installed[id].enabled;
        }
      }
      await this.saveSettings();
      for (const id of stillInstalled) {
        if (installed[id].delayed && installed[id].enabled) {
          const time = installed[id].time * 1e3 || 0;
          setTimeout(
            async () => await this.app.plugins.enablePlugin(id),
            time
          );
        }
        installed[id].toUpdate = false;
      }
    });
    this.addSettingTab(new QPSSettingTab(this.app, this));
    this.addRibbonIcon(
      "toggle-right",
      "Quick Plugin Switcher",
      async (evt) => {
        this.settings.filters = Filters.All;
        this.settings.filtersComm = CommFilters.All;
        await this.installedUpdate();
        new QPSModal(this.app, this).open();
        await this.exeAfterDelay(this.pluginsCommInfo.bind(this));
      }
    );
    this.addCommand({
      id: "quick-plugin-switcher-modal",
      name: "open modal",
      callback: async () => {
        this.settings.filters = Filters.All;
        this.settings.filtersComm = CommFilters.All;
        await this.installedUpdate();
        new QPSModal(this.app, this).open();
        await this.exeAfterDelay(this.pluginsCommInfo.bind(this));
      }
    });
  }
  wrapDisableEnablePluginAndSave(stillInstalled, cb) {
    const installed = this.settings.installed || {};
    const wrapper1 = around(this.app.plugins, {
      disablePluginAndSave(oldMethod) {
        return async function(pluginId) {
          if (stillInstalled.length) {
            const id = stillInstalled.find(
              (id2) => id2 === pluginId && !isEnabled(this, pluginId)
            );
            if (id && installed[id].delayed && installed[id].time > 0) {
              installed[id].enabled = false;
              cb();
            }
          }
          return oldMethod.call(this, pluginId);
        };
      }
    });
    const wrapper2 = around(this.app.plugins, {
      enablePluginAndSave(oldMethod) {
        return async function(pluginId) {
          let altReturn = false;
          if (stillInstalled.length) {
            const id = stillInstalled.find(
              (id2) => id2 === pluginId && isEnabled(this, id2)
            );
            if (id && installed[id].delayed && installed[id].time > 0) {
              installed[id].enabled = true;
              altReturn = true;
              cb();
            }
          }
          if (altReturn)
            return this.app.plugins.enablePlugin.call(
              this,
              pluginId
            );
          return oldMethod.call(this, pluginId);
        };
      }
    });
    return { wrapper1, wrapper2 };
  }
  async installedUpdate() {
    const installed = this.settings.installed || {};
    const manifests = this.app.plugins.manifests || {};
    let stillInstalled = [];
    for (const id in installed) {
      if (id in manifests)
        stillInstalled.push(id);
      else {
        delete installed[id];
      }
    }
    for (const key in manifests) {
      const inListId = stillInstalled.find(
        (id) => id === key
      );
      if (inListId) {
        if (isEnabled(this, key) !== installed[key].enabled && !installed[key].delayed) {
          installed[key].enabled = !installed[key].enabled;
        } else if (installed[key].delayed && isEnabled(this, key) !== installed[key].enabled) {
          if (isEnabled(this, key)) {
            installed[key].enabled = true;
            await this.app.plugins.disablePluginAndSave(
              key
            );
            await this.app.plugins.enablePlugin(
              key
            );
            installed[key].switched++;
          }
        }
        installed[key] = {
          ...installed[key],
          ...manifests[key]
        };
      } else {
        const complement = {
          enabled: isEnabled(this, key) || false,
          switched: 0,
          groupInfo: {
            hidden: false,
            groupIndices: [],
            groupWasEnabled: false
          },
          delayed: false,
          time: 0
        };
        installed[key] = {
          ...manifests[key],
          ...complement
        };
      }
    }
    this.getLength();
    await this.saveSettings();
  }
  getLength() {
    const installed = this.settings.installed;
    this.lengthAll = Object.keys(installed).length;
    this.lengthEnabled = 0;
    this.lengthDisabled = 0;
    for (const key in installed) {
      if (installed[key].enabled) {
        this.lengthEnabled++;
      } else {
        this.lengthDisabled++;
      }
    }
  }
  async pluginsCommInfo() {
    Console.log("fetching'''''''''''''''''''''''''");
    let plugins, stats;
    try {
      plugins = await fetchData(COMMPLUGINS);
      stats = await fetchData(COMMPLUGINSTATS);
    } catch (e) {
      return false;
    }
    if (plugins && stats) {
      const { commPlugins, pluginStats } = this.settings;
      for (const plugin of plugins) {
        let updateStats;
        if (plugin.id in stats) {
          updateStats = {
            downloads: stats[plugin.id].downloads || 0,
            updated: stats[plugin.id].updated || 0
          };
        } else {
          updateStats = {
            downloads: 0,
            updated: 0
          };
        }
        if (plugin.id in commPlugins) {
          commPlugins[plugin.id] = { ...commPlugins[plugin.id], ...plugin, ...updateStats };
        } else {
          const complement = {
            groupCommInfo: {
              hidden: false,
              groupIndices: []
            },
            ...updateStats
          };
          commPlugins[plugin.id] = { ...plugin, ...complement };
        }
      }
      this.settings.pluginStats = { ...this.settings.pluginStats, ...stats };
      this.settings.plugins = plugins.map((plugin) => plugin.id);
      await this.saveSettings();
      Console.log("fetched");
      return true;
    }
    return false;
  }
  async loadSettings() {
    const previousSettings = { ...await this.loadData() };
    if ("allPluginsList" in previousSettings) {
      delete previousSettings.allPluginsList;
      delete previousSettings.pluginStats;
      delete previousSettings.commPlugins;
      Console.log("allPluginsList... has been deleted");
    }
    if ("showReset" in previousSettings) {
      delete previousSettings.showReset;
    }
    this.settings = { ...DEFAULT_SETTINGS, ...previousSettings };
    this.settings.savedVersion = this.manifest.version;
    await this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
